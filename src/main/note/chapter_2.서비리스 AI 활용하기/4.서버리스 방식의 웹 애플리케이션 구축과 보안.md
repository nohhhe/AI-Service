4.서버리스 방식의 웹 애플리케이션 구축과 보안
=========================
## ⭕ 아키텍처
<img src="../../resources/images/chapter_2.서비리스 AI 활용하기/챗봇 아키텍처.jpg" alt="챗봇 아키텍처" style="width: 100%; height: auto;" />
- 웹 애플리케이션: S3 버킷이 클라이언트 애플리케이션에 대한 정적인 콘텐츠를 제공하며, API 게이트웨이가 동기 및 비동기 서비스에서 이벤트 핸들러를 트리거하는 API를 제공한다.
웹 애플리케이션 클라이언트는 AWS 앰플리파이 클라이언트 SDK를 사용하여 복잡한 인증을 처리한다.
- 동기 및 비동기 서비스: 이러한 커스텀 서비스는 API 요청을 처리하고 애플리케이션의 주요 비즈니스 로직을 수행하는 AWS 람다 함수로 구현된다.
- 통신 패브릭: 라우트 53은 DNS 구성에 사용된다. 커스텀 도메인 이름을 사용하여 서비스에 접근할 수 있다.
- 유틸리티 서비스: 코그니토는 인증 및 권한 부여에 사용한다.
- AI 서비스: 관리형 AWS AI 서비스인 트랜스크라이브, 폴리, 렉스를 사용한다.
- 데이터 서비스: 다이나모DB는 강력하고 확장 가능한 데이터베이스로 쓰이며, S3는 파일 저장에 쓰인다.

### ◉ 웹 애플리케이션
프론트엔드는 S3에 배포된 HTML, CSS, 자바스크립트로 구성된 단일 페이지 애플리케이션으로 UI를 렌더링한다.
서비스에 대한 경로는 API 게이트웨이를 사용해 제공한다. 작업 목록 애플리케이션은 프론트엔드에 추가 라이브러리, 즉 AWS 앰플리파이를 사용한다.
이번 실습에서는 AWS 앰플리파이를 사용해 코그니토에 클라이언트 인터페이스를 제공하고 S3에 저장한 음성-텍스트 데이터에 접근할 수 있는 권한을 준다.

#### ❗️ AWS 앰플리파이(Amplify)
웹 및 모바일 애플리케이션 개발을 위한 풀스택 서비스입니다. 백엔드 구축부터 프론트엔드 배포까지 지원하며, AWS의 다양한 서비스와 쉽게 연동할 수 있습니다.

##### 장점
- 서버리스 기반: 인프라 관리 없이 바로 사용 가능
- 빠른 개발 속도: 인증, 데이터베이스, API 등 쉽게 설정 가능
- 풀스택 지원: 프론트엔드 + 백엔드 통합 관리
- 자동 배포 & CI/CD 지원: 코드 변경 시 자동 빌드 및 배포
- GraphQL 지원: AWS AppSync를 활용한 효율적인 데이터 관리

##### 주요 기능
- 앰플리파이 CLI & Admin UI: 백엔드 설정 (Auth, API, Storage, Functions 등)
- 앰플리파이 Hosting: 정적 웹사이트 배포, CI/CD 지원
- 앰플리파이 라이브러리: AWS 서비스와 프론트엔드 연동 (Auth, API, Storage 등)
  - 이번 장에서 사용할 기능은 라이브러리

#### ❗️ 앰플리파이 라이브러리
프론트엔드 애플리케이션에서 AWS 서비스를 쉽게 연동할 수 있도록 제공되는 클라이언트 라이브러리이다. AWS의 인증, API, 데이터 저장소, 분석 기능 등을 간편하게 구현할 수 있도록 돕는다.
이
- Authentification: Amazon Cognito 기반 사용자 인증 (로그인, 회원가입, SNS 로그인)
- API (GraphQL & REST): AWS AppSync(GraphQL) 및 API Gateway(REST) 연동 
- Storage (파일 저장): S3 버킷에 파일 업로드 및 다운로드 
- DataStore (오프라인 데이터 동기화): GraphQL API와 연동하여 오프라인에서도 데이터 사용 가능 
- PubSub (실시간 메시징): IoT, WebSocket 등을 활용한 실시간 데이터 처리 
- Predictions (AI/ML 서비스): 이미지 분석, 음성 변환, 번역 기능 제공 
- Geo (위치 기반 서비스): 지도 렌더링 및 위치 데이터 관리 
- Analytics (사용자 행동 분석): AWS Pinpoint 기반 사용자 이벤트 추적

### ◉ 동기 서비스
작업 목록 서비스로 간단한 CRUD 인터페이스에 대한 경로를 노출한다.
- POST /todo/: 새 항목을 작성한다.
- GET /todo/{id}: 특정 항목을 읽는다.
- PUT /todo/{id}: 특정 항목을 업데이트한다.
- DELETE /todo/{id}: 특정 항목을 삭제한다.
- GET /todos: 모든 항목을 나열한다.

### ◉ 비동기 서비스
비동기 서비스는 음성-텍스트 및 텍스트-음성 변환과 관련된 두 가지가 있다.

#### ✦ 노트 서비스
음성 녹음 메모를 텍스트로 변환하는 인터페이스를 제공한다.
- POST /note: 새 비동기 노트 변환 작업을 시작한다.
- GET /note/{id}: 노트에 대한 정보를 폴링한다.

#### ✦ 일정 서비스
일정을 만들어 음성 녹음을 변환하는 인터페이스를 제공한다.
- POST /schedule: 새 비동기 일정 변환 작업을 시작한다.
- GET /schedule/{id}: 일정에 대한 정보를 폴링한다.

### ◉ 통신 패브릭
간결함을 위해 폴 기반 메커니즘을 사용하여 작업 목록을 작성하고, 큐는 사용하지 않는다. 통신 패블릭 기술로는 주로 HTTP와 DNS를 사용한다.

### ◉ 유틸리티 서비스
사용자 로그인 및 인증을 위해 아마존 코그니토를 사용한다.

### ◉ AI 서비스
- 트랜스크라이브: S3에서 입력 내용을 읽어 음성을 텍스트로 변환한다.
- 폴리: 텍스트를 음성으로 변환하고 S3에 출력 오디오 파일을 기록한다.
- 렉스: 대화형 챗봇 생성에 사용하며, 렉스 웹 UI 시스템을 사용하여 프론트엔드 애플리케이션에 직접 연결한다.

#### ❗️ 트랜스크라이브(Transcribe)
음성을 텍스트로 변환(STT, Speech-to-Text)하는 AWS의 자동 음성 인식(ASR, Automatic Speech Recognition) 서비스이다.

##### 주요 기능
- 오디오 → 텍스트 변환 (STT): 음성을 자동으로 텍스트로 변환
- 다양한 언어 지원: 영어, 한국어 포함 다국어 지원
- 실시간 전사: 실시간 음성을 텍스트로 변환
- 도메인 최적화 가능: 의료, 콜센터 대화 등 특정 도메인 맞춤 학습, 즉 특화된 모델을 제공
- 맞춤 사전: 특정 용어나 브랜드명 인식 향상, 특정 단어를 등록하여 인식률을 높이는 기능
- 맞춤 언어 모델(Custom Language Models, CLM): 특정 비즈니스 분야에 맞춘 모델 학습, 사용자가 직접 데이터를 업로드하여 AI를 학습시키는 방식
- 화자 분리: 여러 화자를 구분하여 텍스트 변환
- 시간 스탬프 제공: 변환된 텍스트에 시간 정보

#### ❗️ 폴리(Polly)
텍스트를 음성으로 변환하는(TTS, Text-to-Speech) AWS 서비스이다.

##### 주요 기능
- 텍스트 → 음성 변환 (TTS, Text-to-Speech): 텍스트를 음성으로 변환
- 다양한 언어 및 음성 지원: 한국어 포함 30개 이상 언어 & 여러 목소리 선택 가능
- Neural TTS: AI 기반 자연스러운 음성 생성
- 음성 감정 조절: 기쁨, 슬픔 등의 감정 표현 가능
- 속도 및 발음 조절: SSML을 사용해 말하기 속도, 억양 조절 가능
- 음성 파일 저장: 음성을 MP3, OGG, PCM 형식으로 저장 가능

#### ❗️ 렉스(Lex)
대화형 챗봇과 음성 인터페이스를 쉽게 구축할 수 있도록 지원하는 AWS 서비스이다.

##### 주요 기능
- 음성 & 텍스트 입력 지원: 사용자의 입력을 음성 또는 텍스트로 받아 처리 가능
- 자연어 이해 기반: AI를 활용한 의도 및 개체 인식
- 다중 언어 지원: 영어, 한국어 등 다양한 언어 지원
- Lambda와 연동 가능: AWS Lambda를 활용하여 복잡한 비즈니스 로직 처리 가능
- 자동 음성 합성 지원: AWS Polly와 연동하여 챗봇이 음성으로 응답 가능
- 채널 통합: Slack, Facebook Messenger, Twilio 등과 연결 가능
- 챗봇 분석 기능: AWS CloudWatch를 통한 사용자 데이터 분석 가능

### ◉ 데이터 서비스
데이터 서비스는 S3와 다이나모DB를 사용한다. 다이나모DB는 확장성이 뛰어난 클라우트 네이티브 NoSQL 데이터베이스로 작업 목록을 저장하기 위해 사용한다.

#### ❗️ 다이나모DB(DynamoDB)
AWS에서 제공하는 서버리스 NoSQL 데이터베이스 서비스이다. 빠르고 확장성이 뛰어난 키-값(Key-Value) 및 문서(Document) 기반 데이터베이스로, 대량의 데이터를 빠르게 처리할 수 있다.

##### 주요 특징
- 서버리스: 인프라 관리 없이 데이터 저장 및 조회 가능
- NoSQL 기반: 관계형 데이터베이스(RDB)와 달리 스키마 없이 유연한 데이터 저장 가능
- 키-값(Key-Value) 및 문서(Document) 데이터 모델 지원: JSON 형식의 데이터를 저장 가능
- 고성능: SSD 기반으로 빠른 데이터 조회 & 자동 캐싱 지원
- 자동 확장 (Auto Scaling): 수요에 따라 읽기/쓰기 성능 자동 조정
- 완전 관리형: 백업, 복원, 모니터링 기능 제공
- ACID 트랜잭션 지원: 원자성, 일관성, 격리성, 지속성을 보장하는 트랜잭션 기능
- 다양한 AWS 서비스와 연동 가능: Lambda, API Gateway, S3, CloudWatch 등과 쉽게 연결 가능

##### 타 NoSQL 데이터베이스와 비교
| 비교 항목            | DynamoDB                     | MongoDB                   | Cassandra                 | DocumentDB                  |
|---------------------|----------------------------|--------------------------|--------------------------|----------------------------|
| 데이터 모델         | 키-값(Key-Value), 문서(Document) | 문서(Document)           | 키-값(Key-Value), 열(Column) 기반 | 문서(Document)              |
| 트랜잭션 지원       | 기본 지원 (제한적)          | 지원                     | 부분 지원                | 지원                        |
| 조인(Join) 가능 여부 | 미지원                      | 미지원                    | 미지원                    | 미지원                      |
| 스키마             | 없음 (스키마리스)            | 없음 (스키마리스)         | 없음 (스키마리스)         | 없음 (스키마리스)            |
| 확장성             | 자동 확장 (Auto Scaling)     | 자동 확장 (Sharding 필요) | 자동 확장 (노드 추가)     | 자동 확장 (Auto Scaling)     |
| 운영 방식          | AWS 완전 관리형 서버리스     | 자체 호스팅 또는 Atlas (Managed) | 자체 호스팅 필요         | AWS 완전 관리형 (MongoDB 호환) |
| 읽기 성능          | 고속 (DAX 캐싱 지원)         | 빠름                     | 매우 빠름                 | 빠름                        |
| 쓰기 성능          | 초당 수백만 요청 가능        | 빠름                     | 매우 빠름                 | 빠름                        |
| 다중 리전 지원      | 지원 (Global Tables)        | 지원 (Sharding)          | 지원                      | 지원 (Multi-AZ)            |
| 주요 사용 사례      | 서버리스, IoT, 게임, 챗봇, E-commerce | 범용 NoSQL, 웹앱        | 분산 데이터, 대량 데이터  | MongoDB 기반 AWS 애플리케이션 |
| AWS 연동 최적화     | 매우 높음                    | 낮음                     | 낮음                      | 높음                        |
| 비용               | 사용량 기반 과금 (비싼 편)   | 저장 용량 기반 (저렴)    | 대량 데이터 저장 시 저렴  | 사용량 기반 과금 (비싼 편)  |

##### ❓카산드라는 트랜잭션을 지원하지 않는 것으로 아는데?
단일 파티션 내에선만 경량 트랜잭션을 지원하며 복잡한 다중 파티션 트랜잭션은 지원하지 않는다.

#### ❗카산드라에서 경량 트랜잭션(LWT, Lightweight Transactions)이란?
동시성 문제를 해결하기 위해 CAS(Compare-And-Set) 메커니즘을 사용하는 트랜잭션 방식이다.

카산드라는 기본적으로 트랜잭션을 지원하지 않음 → 동시 업데이트 시 충돌 가능하다. 이를 해결하기 위해 경량 트랜잭션을 사용하여 동시성 제어한다.

##### 경량 트랜잭션 동작 방식
1. 비교: 기존 데이터를 확인하고 조건을 평가함
2. 설정: 조건이 충족되면 데이터 변경을 수행함
3. Paxos 합의: 여러 노드가 변경 사항을 동의하고 반영함
4. 적용: 최종적으로 변경이 커밋됨

##### 경량 트랙잰션 사용 예제
1. IF NOT EXISTS를 사용한 안전한 삽입
```sql
-- id=1인 사용자가 없을 때만 삽입됨 → 중복 삽입 방지 가능.
INSERT INTO users (id, name, email) 
VALUES (1, 'Alice', 'alice@example.com') 
IF NOT EXISTS;
```

2. 조건부 업데이트 (IF column=value)
```sql
-- email='alice@example.com'일 때만 업데이트됨 → 최신 데이터 보장 가능
UPDATE users
SET email = 'newalice@example.com'
WHERE id = 1
  IF email = 'alice@example.com';
```

3. 존재할 때만 삭제 (IF EXISTS)
```sql
-- id=1이 존재할 때만 삭제됨 → 없는 데이터 삭제 방지
DELETE FROM users
WHERE id = 1
  IF EXISTS;
```

##### 경량 트랜잭션의 장점
- 데이터 정합성 보장 → 동시 업데이트 충돌 방지
- 낙관적 잠금(Optimistic Locking) → 성능 저하 없이 동시성 제어
- 조건부 업데이트 가능 → 기존 값이 특정 값일 때만 변경

##### 경량 트랜잭션의 단점
- 성능 저하 → Paxos 합의 과정으로 인해 일반 쿼리보다 느림
- 병렬 처리 제약 → 모든 노드에서 동기화가 필요하므로 대량 업데이트 시 성능 저하
- 쓰기 부하 증가 → 일반적인 카산드라의 높은 쓰기 성능을 희생해야 함

##### 다이나모 DB를 사용하는 경우
- AWS 생태계 내에서 서버리스, 자동 확장, 고속 읽기/쓰기가 필요한 경우 DynamoDB가 최적의 선택
- 관계형 데이터, SQL 기반 분석, 복잡한 검색 기능이 필요한 경우 다른 DB를 고려하는 것이 좋음

## ⭕ 준비 작업
- AWS 계정
- AWS 커맨드라인 설치 및 설정
- Node.js 설치
- 서버리스 프레임워크 설치

### ◉ 코드 다운로드
소스코드는 https://github.com/hanbit/ai-as-service 저장소의 chapter4 디렉토리에 있다.
> git clone https://github.com/hanbit/ai-as-service.git

## ⭕ 1단계: 기본 애플리케이션
단일 API 게이트웨이 배포, 일부 간단한 람다 함수, 다이나모DB 테이블 및 S3에서 제공되는 일부 프론트엔드 코드를 사용한다.

### ◉ 리소스
serverless.yml 파일은 프론트엔드용 S3 버킷을 정의하고 권한을 설정하며 CORS를 화성화한다. serverless-dotenv-plungin이라는 새로운 플러그인을 사용하여 환경 변수를 설정한다.

##### serverless-dotenv-plungin 플러그인
serverless-dotenv-plugin은 Serverless Framework에서 .env 파일을 로드하여 환경 변수를 자동으로 설정하는 플러그인이다.

### ◉ 작업 목록 서비스
<img src="../../resources/images/chapter_2.서비리스 AI 활용하기/작업 목록 서비스.jpg" alt="작업 목록 서비스" style="width: 100%; height: auto;" />

serverless.yml에서는 핸들러 함수를 위하여 다이나모 DB에 대한 접근을 설정 경로 및 핸들러 함수를 정의한다.
```yaml
service: chapter4-todo
frameworkVersion: ">=4.0.0"
plugins:
  - serverless-offline
  - serverless-domain-manager
  - serverless-dotenv-plugin
custom:
  region: ${env:AWS_DEFAULT_REGION, 'ap-northeast-2'}
  accountid: ${env:AWS_ACCOUNT_ID}
  domain: ${env:CHAPTER4_DOMAIN}
  dotenv:
    path: ../.env
  customDomain:
    domainName: 'chapter4api.${self:custom.domain}'
    stage: ${self:provider.stage}
    basePath: api
    certificateName: '*.${self:custom.domain}'
    certificateArn: ${env:CHAPTER4_DOMAIN_ARN}
    createRoute53Record: true
    endpointType: regional
  serverless-offline:
    port: 3000

provider:
  name: aws
  runtime: nodejs20.x
  stage: ${opt:stage, 'dev'}
  region: ${env:AWS_DEFAULT_REGION, 'ap-northeast-2'}
  environment:
    TODO_TABLE: '${self:service}-${self:provider.stage}'
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:DescribeTable
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
      Resource: "arn:aws:dynamodb:${self:custom.region}:${self:custom.accountid}:*"

functions:
  create:
    handler: handler.create
    events:
      - http:
          method: POST
          path: todo
          cors: true

  read:
    handler: handler.read
    events:
      - http:
          method: GET
          path: todo/{id}
          cors: true
  update:
    handler: handler.update
    events:
      - http:
          method: PUT
          path: todo/{id}
          cors: true
  delete:
    handler: handler.delete
    events:
      - http:
          method: DELETE
          path: todo/{id}
          cors: true
  list:
    handler: handler.list
    events:
      - http:
          method: GET
          path: todo
          cors: true

resources:
  - ${file(./dynamodb.yml)}
```

- iamRoleStatements: 함수가 사용할 IAM 역할을 정의한다.
 - dynamodb:DescribeTable: 테이블에 대한 설명을 가져오는 데 사용
 - dynamodb:Query: 테이블에서 항목을 쿼리하는 데 사용
 - dynamodb:Scan: 테이블에서 모든 항목을 스캔하는 데 사용
 - dynamodb:GetItem: 테이블에서 특정 항목을 가져오는 데 사용
 - dynamodb:PutItem: 테이블에 새 항목을 추가하는 데 사용
 - dynamodb:UpdateItem: 테이블의 기존 항목을 업데이트하는 데 사용
 - dynamodb:DeleteItem: 테이블에서 항목을 삭제하는 데 사용

테이블 이름을 핸들러 함수로 하드 코딩하면 DRY 원칙을 위반하므로 아래 방식을 권장한다.
> TODO_TABLE: '${self:service}-${self:provider.stage}'

##### DRY 원칙
Don't Repeat Yourself의 약자로, 중복을 피하고 코드의 재사용성을 높이기 위한 소프트웨어 개발 원칙이다.

서버리스 정의를 보다 관리하도록, 다이나모DB 테이블 정의를 dynamodb.yml 이라는 별도의 파일을 배치하여 기본 serverless.yml 파일에 포함되도록 선택한다.
```yaml
Resources:
  TodosDynamoDbTable:
    Type: 'AWS::DynamoDB::Table'
    DeletionPolicy: Retain
    Properties:
      AttributeDefinitions:
        -
          AttributeName: id
          AttributeType: S
      KeySchema:
        -
          AttributeName: id
          KeyType: HASH
      ProvisionedThroughput:
        ReadCapacityUnits: 1
        WriteCapacityUnits: 1
      TableName: '${self:service}-${self:provider.stage}'

  GatewayResponseDefault4XX:
    Type: 'AWS::ApiGateway::GatewayResponse'
    Properties:
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
      ResponseType: DEFAULT_4XX
      RestApiId:
        Ref: 'ApiGatewayRestApi'
```

- Type: 'AWS::DynamoDB::Table': 다이나모DB 테이블을 생성하는 리소스 유형
- DeletionPolicy: Retain: 스택 삭제 시 테이블을 유지하도록 설정
- AttributeDefinitions: 테이블의 속성 정의
 - AttributeName: id: 속성 이름
 - AttributeType: S: 속성의 데이터 유형 (문자열)
- KeySchema: 테이블의 기본 키 정의
 - AttributeName: id: 기본 키로 사용할 속성 이름
 - KeyType: HASH: 키 유형 (해시)
- ProvisionedThroughput: 테이블의 읽기/쓰기 처리량 설정
 - ReadCapacityUnits: 1: 초당 1개의 읽기 가능
 - WriteCapacityUnits: 1: 초당 1개의 쓰기 가능
- TableName: '${self:service}-${self:provider.stage}': 테이블 이름을 서비스 이름과 스테이지로 설정
- GatewayResponseDefault4XX: API 게이트웨이 응답을 설정하는 리소스
 - Type: 'AWS::ApiGateway::GatewayResponse': API 게이트웨이 응답을 생성하는 리소스 유형 
 - ResponseParameters: 응답 헤더를 설정
  - gatewayresponse.header.Access-Control-Allow-Origin: "'*'": 모든 도메인에서 API 요청 허용
  - gatewayresponse.header.Access-Control-Allow-Headers: "'*'": 모든 HTTP 헤더 허용
 - ResponseType: DEFAULT_4XX: 기본 4XX 응답
 - RestApiId: Ref: 'ApiGatewayRestApi': API 게이트웨이 리소스 ID 참조, 즉 현재 배포되는 API Gateway와 연결됨

##### 다이나모DB 컬럼 타입
- S: 문자열
- N: 숫자
- B: 바이너리 데이터

##### 다이나모 DB 키 유형
- HASH: 해시 키 (기본 키)
- RANGE: 범위 키 (복합 키)

작업 목록 서비스를 위해 handler.js 파일을 작성한다.
```javascript
'use strict'

const uuid = require('uuid')
const AWS = require('aws-sdk')
// 다이나모DB와 상호작용할 수 있는 DocumentClient 객체를 생성
const dynamoDb = new AWS.DynamoDB.DocumentClient()
const TABLE_NAME = { TableName: process.env.TODO_TABLE }

// 응답을 생성하는 함수
function respond (err, body, cb) {
  let statusCode = 200

  body = body || {}
  if (err) {
    body.stat = 'err'
    body.err = err
    if (err.statusCode) {
      statusCode = err.statusCode
    } else {
      statusCode = 500
    }
  } else {
    body.stat = 'ok'
  }

  const response = {
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Credentials': true,
      statusCode: statusCode
    },
    body: JSON.stringify(body)
  }

  cb(null, response)
}

// action과 note가 빈 문자열이면 null로 변경 (다이나모 DB에 빈 문자열을 저장할 수 없음)
function removeEmpty (data) {
  if (data.action.length === 0) { data.action = null }
  if (data.note.length === 0) { data.note = null }
}

// 다이나모 DB에 데이터를 저장하는 함수
module.exports.create = (event, context, cb) => {
  const data = JSON.parse(event.body)
  // action과 note가 빈 문자열이면 null로 변경
  removeEmpty(data)

  // uuid를 생성하여 id로 사용
  data.id = uuid.v1()
  data.modifiedTime = new Date().getTime()

  const params = { ...TABLE_NAME, Item: data }
  // DynamoDB에 데이터를 저장
  dynamoDb.put(params, (err, data) => {
    respond(err, {data: data}, cb)
  })
}

// 다이나모 DB에서 데이터를 읽어오는 함수
module.exports.read = (event, context, cb) => {
  const params = { ...TABLE_NAME, Key: { id: event.pathParameters.id } }
  // DynamoDB에서 데이터를 읽어옴
  dynamoDb.get(params, (err, data) => {
    respond(err, data, cb)
  })
}

// 다이나모 DB에 데이터를 업데이트하는 함수 (다이나모 DB put은 Upsert 동작)
module.exports.update = (event, context, cb) => {
  const data = JSON.parse(event.body)
  removeEmpty(data)

  data.id = event.pathParameters.id
  data.modifiedTime = new Date().getTime()
  const params = { ...TABLE_NAME, Item: data }

  // DynamoDB에 데이터를 업데이트
  dynamoDb.put(params, (err, data) => {
    console.log(err)
    console.log(data)
    respond(err, data, cb)
  })
}

// 다이나모 DB에서 데이터를 삭제하는 함수
module.exports.delete = (event, context, cb) => {
  const params = { ...TABLE_NAME, Key: { id: event.pathParameters.id } }
  // DynamoDB에서 데이터를 삭제
  dynamoDb.delete(params, (err, data) => {
    respond(err, data, cb)
  })
}

// 다이나모 DB에서 데이터를 읽어오는 함수 (모든 데이터를 읽어옴)
module.exports.list = (event, context, cb) => {
  const params = TABLE_NAME
  // DynamoDB에 데이터를 스캔
  dynamoDb.scan(params, (err, data) => {
    respond(err, data, cb)
  })
}
```

### ◉ 프론트엔드
<img src="../../resources/images/chapter_2.서비리스 AI 활용하기/프론트엔드.jpg" alt="프론트엔드" style="width: 100%; height: auto;" />

- index.html: 기본 HTML 파일
- index.js: 애플리케이션 진입점
- todo.js: 작업 목록의 모델 및 컨트롤러 코드
- todo-view.js: 작업 목록 DOM의 조작
- template.js: 일반적인 렌더링 템플릿

```html
// index.html
<html>
<head>
  <title>Chapter 4-5</title>
</head>
<body>
  <script src='main.js'></script>

	<nav class="navbar navbar-expand-lg navbar-light bg-light">
		<a class="navbar-brand" href="#">Serverless AI Chapter 4-5</a>
		<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
			<span class="navbar-toggler-icon"></span>
		</button>
		<div class="collapse navbar-collapse" id="navbarNav">
		</div>
	</nav>

	<div id="content">
	</div>

	<div id="footer">
		<div id="error"></div>
	</div>

</body>
</html>
```

```javascript
// index.js
'use strict'

import $ from 'jquery'
import 'bootstrap/dist/css/bootstrap.min.css'
import 'webpack-jquery-ui/css'
import {todo} from './todo'

$(function () {
  todo.activate()
})
```

```javascript
// todo.js
'use strict'

import $ from 'jquery'
import {view} from './todo-view'

const todo = {activate}
export {todo}

const API_ROOT = `https://chapter4api.${process.env.CHAPTER4_DOMAIN}/api/todo/`

// 사용자 입력을 수집하여 객체로 반환
function gather () {
  return {
    id: $('#todo-id').val(),
    dueDate: $('#todo-duedate').val(),
    action: $('#todo-action').val(),
    stat: $('#todo-stat').is(':checked') ? 'done' : 'open',
    note: $('#todo-note').val()
  }
}

// 새로운 작업을 생성
function create (cb) {
  $.ajax(API_ROOT, {
    data: JSON.stringify(gather()),
    contentType: 'application/json',
    type: 'POST',
    success: function (body) {
      if (body.stat === 'ok') {
        // 작업 목록을 다시 불러옴
        list(cb)
      } else {
        $('#error').html(body.err)
        cb && cb()
      }
    }
  })
}

// 작업을 업데이트
function update (cb) {
  $.ajax(API_ROOT + $('#todo-id').val(), {
    data: JSON.stringify(gather()),
    contentType: 'application/json',
    type: 'PUT',
    success: function (body) {
      if (body.stat === 'ok') {
        list(cb)
      } else {
        $('#error').html(body.err)
        cb && cb()
      }
    }
  })
}

// 작업을 삭제
function del (id) {
  $.ajax(API_ROOT + id, {
    type: 'DELETE',
    success: function (body) {
      if (body.stat === 'ok') {
        list()
      } else {
        $('#error').html(body.err)
      }
    }
  })
}

// 작업 목록을 불러옴
function list (cb) {
  $.get(API_ROOT, function (body) {
    if (body.stat === 'ok') {
      // 작업 목록을 렌더링
      view.renderList(body)
    } else {
      // 에러 메시지를 렌더링
      view.renderError(body)
    }
    cb && cb()
  })
}

// 리스트 관련 이벤트 핸들러를 바인딩
function bindList () {
  // 편집 이벤트 바인딩
  $('.todo-item-edit').unbind('click')
  $('.todo-item-edit').on('click', (e) => {
    // 편집 영역을 렌더링하고 데이터를 채움
    view.renderEditArea(e.currentTarget.id)
  })

  // 삭제 이벤트 바인딩
  $('.todo-item-delete').unbind('click')
  $('.todo-item-delete').on('click', (e) => {
    // 작업을 삭제
    del(e.currentTarget.id)
  })
}

// 편집 관련 이벤트 핸들러를 바인딩
function bindEdit () {
  // 새로운 작업 생성 이벤트 바인딩
  $('#input-todo').unbind('click')
  $('#input-todo').on('click', e => {
    e.preventDefault()
    // 편집 영역을 렌더링
    view.renderEditArea()
  })

  // 저장 이벤트 바인딩
  $('#todo-save').unbind('click')
  $('#todo-save').on('click', e => {
    e.preventDefault()
    if ($('#todo-id').val().length > 0) {
      // 작업을 업데이트
      update(() => {
        view.renderAddButton()
      })
    } else {
      // 새로운 작업을 생성
      create(() => {
        view.renderAddButton()
      })
    }
  })

  // 취소 이벤트 바인딩
  $('#todo-cancel').unbind('click')
  $('#todo-cancel').on('click', e => {
    e.preventDefault()
    view.renderAddButton()
  })
}

// 초기화 함수
function activate () {
  // 작업 목록 및 리스트, 편집 관련 이벤트를 바인딩
  list(() => {
    bindList()
    bindEdit()
  })

  // content 하위 DOM 변경 시 이벤트 재 바인딩
  $('#content').bind('DOMSubtreeModified', () => {
    bindList()
    bindEdit()
  })
}
```

```javascript
// todo-view.js
'use strict'

import $ from 'jquery'
import 'webpack-jquery-ui/datepicker'
import { todoListTpl, addTpl, editTpl, errTpl } from './templates'

const view = { renderList, renderAddButton, renderEditArea, renderError }
export { view }

// 작업 목록을 렌더링 하는 함수
function renderList (body) {
  $('#content').html(todoListTpl(body.Items))
}

// 작업 추가 버튼을 렌더링 하는 함수
function renderAddButton () {
  $('#edit-area').html(addTpl())
}

// 편집 영역을 렌더링하고 id가 있으면 데이터를 채움
function renderEditArea (id) {
  // 편집 영역을 렌더링
  $('#edit-area').html(editTpl())
  // $('#todo-duedate').datepicker() 없어도 되지 않을까?
  setTimeout(function () {
    $('#todo-duedate').datepicker()
    // id가 있으면 편집 영역을 채움
    if (id) {
      $('#todo-id').val(id)
      $('#todo-duedate').val($('#' + id + ' #due-date').text())
      $('#todo-action').val($('#' + id + ' #action').text())
      // 완료 상태인 경우 체크박스를 체크
      if ($('#' + id + ' #stat').text() === 'done') {
        $('#todo-stat').prop('checked', true)
      }
      $('#todo-note').val($('#' + id + ' #note').text())
    }
  }, 100)
}

// 에러 메시지를 렌더링 하는 함수
function renderError (body) {
  $('#error').html(errTpl(body.err))
}
```

```javascript
// template.js
'use strict'

export { todoListTpl, editTpl, addTpl, errTpl, navBarTpl, navBarScheduleTpl }

// 작업 템플릿 생성
function todoItemTpl (item) {
  return `
    <div id="${item.id}" class="row list-group-item d-flex justify-content-between align-items-center">
      <div class="col-sm-1"></div>
      <div id="due-date" class="col-sm-2">${item.dueDate}</div>
      <div id="action" class="col-sm-3 ">${item.action}</div>
      <div id="note" class="col-sm-3">${item.note === null ? '' : item.note}</div>
      <div id="stat" class="col-sm-1 badge badge-secondary badge-pill">${item.stat}</div>
      <div id="${item.id}" class="col-sm-1 badge badge-danger badge-pill todo-item-delete">Delete</div>
      <div id="${item.id}" class="col-sm-1 badge badge-primary badge-pill todo-item-edit">Edit</div>
    </div>`
}

// 작업 목록을 템플릿 형태로 생성
function todoListTpl (items) {
  let output = ''
  items.forEach(item => {
    output += todoItemTpl(item)
  })


  return `
  <div id="todo-list">
    <div class="row list-group-item d-flex justify-content-between align-items-center">
      <div class="col-sm-1"></div>
      <div class="col-sm-2">Due</div>
      <div class="col-sm-3">Action</div>
      <div class="col-sm-3">Notes</div>
      <div class="col-sm-1">Status</div>
      <div class="col-sm-1"></div>
      <div class="col-sm-1"></div>
    </div>
    ${output}
  </div>
  <div id="edit-area" class="list-group">
    <li class="list-group-item d-flex justify-content-between align-items-center">
      <span id="input-todo" class="badge badge-success badge-pill">new</span>
    </li>
  </div>`
}

// 작업 편집 템플릿 생성
function editTpl () {
  return `
    <div class="row">&nbsp;</div>
    <div class="row">
    <div class="row">
      <div class="col-sm-6">
        <div class="row">
          <div class="col-sm-1"></div><div class="col-sm-1">Due: </div><div class="col-sm-6"><input  class="w-100" type="text" id="todo-duedate"></div>
        </div>
        <div class="row">&nbsp;</div>
        <div class="row">
          <div class="col-sm-1"></div><div class="col-sm-1">Action: </div><div class="col-sm-6"><input class="w-100" type="text" id="todo-action"></div>
        </div>
        <div class="row">&nbsp;</div>
        <div class="row">
          <div class="col-sm-1"></div><div class="col-sm-1">Done: </div><div class="col-sm-6"><input type="checkbox" id="todo-stat"></div>
        </div>
        <div class="row">&nbsp;</div>
        <div class="row">
          <div class="col-sm-1"></div>
          <div class="col-sm-1"><button id="todo-save">save</button></div>
          <div class="col-sm-1"><button id="todo-cancel">cancel</button></div>
          <input type="hidden" id="todo-id">
        </div>
      </div>
      <div class="col-sm-6">
        <div class="row">
          <div class="col-sm-1">Note: </div>
          <div class="col-sm-6">
            <textarea id="todo-note" rows="5" cols="50" maxlength="5000" wrap="hard"></textarea>
          </div>
        </div>
      </div>
    </div>`
}

// 작업 추가 템플릿 생성
function addTpl () {
  return `<li class="list-group-item d-flex justify-content-between align-items-center">
    <span id="input-todo" class="badge badge-success badge-pill">new</span>
  </li>`
}

// 에러 템플릿 생성
function errTpl (err) {
  return `<div class="error">${JSON.stringify(err)}</div>`
}

// 사용하지 않는 함수?
function navBarTpl (isAuth) {
  let link

  if (isAuth) {
    link = '<a class="nav-link" href="#" id="logout">Logout</a>'
  } else {
    link = '<a class="nav-link" href="#" id="login">Login</a>'
  }

  return `
  <ul class="navbar-nav" id='navbar-list'>
    <li class="nav-item">
      ${link}
    </li>
  </ul>`
}

// 사용하지 않는 함수?
function navBarScheduleTpl () {
  return `
    <li class="nav-item">
      <button id='todo-schedule'>schedule</button>
    </li>`
}
```

디스플레이 기능은 todo-view.js 및 template.js가 처리한다.

프론트엔드 디렉토리의 루트에는 세 종류의 제어 파일 package.json, webpack.config.js, serverless.yml이 있다.
이 파일을 사용하여 자바스크립트 종속성을 설치하여 관리하고, 배포할 프론트엔드 버전을 빌드하고, 빌드를 배포할 S3 버킷을 만들 수 있다.

#### ✦ 웹팩
JavaScript 애플리케이션을 위한 모듈 번들러이다. HTML, CSS, JavaScript, 이미지, 폰트 등 다양한 리소스를 하나의 파일 또는 최적화된 여러 개의 파일로 묶어주는 도구이다.

##### 장점
- 파일을 하나로 묶어 관리가 편리함
- 모듈 시스템(ES6 import, CommonJS require) 지원
- 코드를 최적화하여 성능 개선 가능 (압축, 난독화)
- CSS, 이미지, TypeScript 등 다양한 파일을 처리 가능
- 자동으로 변경된 파일을 감지하여 빠른 개발 가능

### ◉ 1단계 배포
환경 변수 설정이 필요하다.
> TARGET_REGION=ap-northeast-2
> CHAPTER4_BUCKET=<사용할 버킷 이름>
> CHAPTER4_DATA_BUCKET=<데이터 버킷 이름>
> CHAPTER4_DOMAIN=<사용할 도메인>
> CHAPTER4_DOMAIN_ARN=<도메인 인증서의 ARN>

#### ✦ 리소스 배포
resources 디렉토리로 이동하여 배포한다.
> npm install
> serverless deploy

##### ❗️BucketOwnerEnforced 세팅 에러
2023년부터 AWS S3에서 ObjectOwnership 기본값이 BucketOwnerEnforced로 자동 설정된다.
AWS는 ACL(Access Control List) 사용을 점점 줄이고 있으며, BucketOwnerEnforced 모드에서는 ACL을 지원하지 않음.
AccessControl: PublicRead 설정을 삭제하고 아래 설정을 추가하여 해결한다.
```yaml
DataBucket:
  Type: AWS::S3::Bucket
  Properties:
    BucketName: ${self:custom.dataBucket}
    OwnershipControls:
      Rules:
        - ObjectOwnership: BucketOwnerPreferred  # ACL 없이 객체 소유 가능
```

#### ✦ 작업 목록 서비스 배포
todo-service 디렉토리로 진입하여 배포한다.
> npm install

##### 도메인 생성
> serverless create_domain

##### 서비스 배포
> serverless deploy

#### ✦ 프론트엔드 배포
frontend 디렉토리로 이동하여 배포한다.
> npm install
> serverless deploy
> source ../.env
> npm run build

##### S3 버킷에 파일 복사
> aws s3 sync dist/ s3://$CHAPTER4_BUCKET

## ⭕ 2단계: 코그니토를 통한 보안 추가
사용자 로그인 및 관리 문제에 대한 기존의 해결책이 있어서, 코드를 직접 작성할 필요 없이 클라우드 네이티브 서비스를 사용하여 처리할 수 있다.
몇 가지 옵션이 있지만 이 시스템에서는 AWS 코그니토를 사용할 것이다. 코그니토는 다음을 포함한 전체 인증 서비스를 제공한다.
- 암호 복잡도 정책
- 웹과 모바일 애플리케이션의 통합
- 다중 로그인 전략
- 사용자 관리
- 암호 복잡도 규칙
- 싱글 사인 온(SSO)
- 페이스북, 구글, 아마존 등을 통한 소셜 로그인
- 보안 모범 사례 및 알려진 최신 보안 취약성에 대한 방어

<img src="../../resources/images/chapter_2.서비리스 AI 활용하기/인증 시스템 아키텍처.jpg" alt="인증 시스템 아키텍처" style="width: 100%; height: auto;" />

AWS 서비스에 인증을 통하여 접속하는 자바스크립트 라이브러리로 AWS 앰플리파이를 프론트엔드에 추가했다. 여기서는 인증 및 접근 제어 목적으로만 사용한다.
로그인에 성공했을 때 제공된 토큰을 API 게이트웨이에 대한 API 호출로 전달해, AWS 람다 핸들러 함수가 사용하도록 한다.

로그인 작업은 코그니토에 인계한다. 사용자가 인증되면 앰플리파이 라이브러리에서 관리하는 세션 토큰이 할당된다. 그런 다음 사용자가 유효한 JSON 웹토큰을 제공할 때만 요청을 허용하는 인증 단계를 API 게이트웨이 설정에 추가한다. 그러면 유효한 웹 토큰을 가지고 있지 않는 모든 요청은 거부하게 된다.

#### ❗️ 싱글 사인 온(SSO) 
한 번의 로그인으로 여러 개의 서비스나 시스템에 자동으로 접근할 수 있게 해주는 인증 방식이다.

##### SSO 동작 방식
1. 사용자가 SSO 로그인 포털에서 ID/PW 입력 후 로그인
2. SSO 시스템이 사용자의 인증 토큰을 생성
3. 사용자가 다른 서비스(A, B, C 등)에 접속하면, SSO 시스템이 인증 토큰을 확인하고 자동 로그인 처리
4. 사용자는 각각의 서비스에서 추가 로그인 없이 사용 가능

##### SSO의 장점
- 편리함: 여러 시스템에 로그인할 필요 없음
- 보안 강화: 비밀번호 입력 횟수가 줄어 피싱 위험 감소
- 관리 효율성: 기업에서 직원 계정을 중앙에서 관리 가능

##### SSO의 단점
- 보안 취약점: SSO 계정이 해킹되면 연결된 모든 서비스가 위험할 수 있음
- 구현 복잡성: OAuth, SAML 같은 프로토콜을 사용해야 해서 개발이 어려울 수 있음
- 의존성 증가: SSO 시스템에 문제가 생기면 모든 서비스 로그인 불가

#### ❗️코그니토란?
AWS에서 제공하는 로그인, 회원가입, 인증(SSO, MFA), 접근 권한 관리 같은 사용자 인증 및 접근 제어 기능을 쉽게 구현할 수 있도록 도와주는 서비스이다.

##### 핵심 기능
- 사용자 인증: 이메일, 비밀번호, 소셜 로그인(Facebook, Google, Apple) 지원
- 다중 인증(MFA): OTP, SMS 인증을 추가하여 보안 강화
- SSO 지원: 기업용 SSO 연동(AWS IAM, OAuth, SAML, OpenID)
- Access Token 발급: JWT(JSON Web Token)를 발급하여 API 인증
- 사용자 정보 저장: 가입한 사용자 계정을 안전하게 저장 및 관리
- 권한 관리: AWS 리소스(S3, DynamoDB 등)에 대한 권한 제어

##### 주요 구성 요소
1. 사용자 풀
- 회원가입, 로그인, 인증을 담당하는 사용자 관리 시스템
- OAuth 2.0 / OpenID Connect 기반으로 JWT 토큰을 발급
- 소셜 로그인과 연동 가능

2. ID 풀
- AWS 리소스에 접근할 수 있도록 권한을 부여하는 시스템
- 로그인한 사용자가 AWS 서비스에 접근할 수 있도록 임시 IAM 역할(Role) 제공
- 익명 사용자(로그인하지 않은 사용자)도 AWS 리소스 접근 가능

##### 사용 흐름
1. 사용자가 Cognito 사용자 풀에서 로그인
2. JWT(Access Token, ID Token)를 발급받음
3. ID 풀을 통해 AWS 리소스 접근 권한을 얻음
4. 사용자는 IAM 역할을 기반으로 AWS 서비스 이용 가능

##### 장점
- 서버리스 인증 구현 가능: 백엔드 없이 사용자 인증 및 관리 가능
- OAuth 2.0, OpenID Connect 지원: 다양한 인증 방식과 소셜 로그인 제공
- 다중 인증 지원: OTP, SMS 인증으로 보안 강화
- AWS 서비스와 쉽게 연동 가능: S3, DynamoDB 등 AWS 리소스 접근 제어 가능
- IAM 역할 기반 권한 관리: 사용자의 AWS 서비스 접근 권한을 세밀하게 조정 가능

##### 단점
- 커스텀 인증 로직이 어려움: 기본 제공 기능 외에는 Lambda 트리거를 활용해야 함
- UI 커스터마이징 제한적: 기본 제공되는 로그인 UI(Custom UI 적용 가능하지만 번거로움)
- 무료 한도 초과 시 비용 발생: 월 5만 명 이상의 활성 사용자부터 과금됨

##### 비용 (서울 리전 기준)
- Lite: 소셜 ID 및 SAML/OIDC 공급자 통합, 암호 기반 인증을 비롯한 기본 사용자 등록, 인증, 관리 기능을 제공합니다. Lite는 가치 지향적 사용 사례를 위한 요금 티어입니다. Lite에는 2024년 11월 22일 이전에 사용 가능한 모든 Cognito 사용자 풀 기능(고급 보안 기능 제외)이 포함됩니다.
  - 첫 10,000명 무료
  - 10,001명~100,000명 $0.0055/MAU
  - 100,001명~1,000,000명 $0.0046/MAU
  - 1,000,001명~10,000,000명	$0.00325/MAU
  - 10,000,000명 초과 $0.0025/MAU 
- Essentials: 포괄적이고 유연한 사용자 인증 및 액세스 제어 기능을 제공하여 고객이 몇 분 만에 애플리케이션에 안전하고 확장 가능한 사용자 지정 가입 및 로그인 경험을 구현할 수 있도록 지원합니다. Essentials는 Lite의 모든 기능을 포함하며, 관리형 로그인 및 패스키, 이메일 또는 SMS를 사용하는 암호 없는 로그인 옵션도 지원합니다. 또한 Essentials는 액세스 토큰 사용자 지정과 암호 재사용 금지 기능도 지원합니다.
  - 첫 10,000명 무료, 그 이후 $0.015/MAU
- Plus: 의심스러운 로그인을 막는 위협 방지 기능을 제공하여 애플리케이션 보안 요구가 높은 고객을 대상으로 합니다. Plus에는 모든 Essentials 티어의 기능이 포함되어 있으며, 이에 추가로 위험 기반 적응형 인증, 손상된 자격 증명 탐지, 위협 신호 분석을 위한 사용자 인증 이벤트 로그 내보내기 기능을 지원합니다.
  - $0.02/MAU
- 고급 보안 기능, 다중 인증 SMS 메시지 등을 사용하는 경우 추가 요금을 낼 수 있다.
- 참고: https://aws.amazon.com/ko/cognito/pricing/

#### ❗️JWT(JSON Web Token)
서버와 클라이언트 간의 인증 및 정보 교환을 위해 사용되는 JSON 기반의 토큰이다.

##### 특징
- 자기 포함: 토큰 내부에 필요한 정보를 직접 포함하고 있어서 별도의 데이터베이스 조회 없이 검증이 가능
- JSON 기반: 가벼운 JSON 형식으로 구성되어 있으며, HTTP 요청의 헤더, URL 파라미터, 쿠키 등에 쉽게 포함될 수 있음
- 디지털 서명 포함: HMAC, RSA, ECDSA 같은 서명 알고리즘을 사용하여 변조 여부를 검증할 수 있음
- 무상태: 서버가 세션 정보를 저장할 필요 없이 클라이언트가 JWT를 보관하고 사용함

##### 구조
JWT는 헤더(Header).페이로드(Payload).서명(Signature) 세 부분으로 나뉘며, 각 부분은 .(점)으로 구분됨
- 헤더: 토큰의 유형과 해싱 알고리즘 정보를 담고 있음, 서버는 이 값을 보고 어떤 방식으로 서명을 검증할지 결정, base64로 인코딩
```json
{
  "alg": "HS256",  // HMAC-SHA256 서명 방식 사용
  "typ": "JWT"
}
```

- 페이로드: 실제 포함할 정보 (사용자 ID, 권한, 만료 시간 등), 민감한 정보는 암호화되지 않으므로 그대로 저장하면 안 됨, base64로 인코딩
```json
{
  "sub": "1234567890", // 사용자 ID
  "name": "name",      // 사용자 이름
  "iat": 1516239022,  // 발급 시간 (Issued At)
  "exp": 1616239022   // 만료 시간 (Expiration)
}
```

- 서명: JWT가 변조되지 않았음을 증명하기 위해 사용됨, 서버의 비밀 키(secret key)와 서명 알고리즘을 이용해 생성
```plaintext
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret_key
)
```

##### 동작 방식
1. 클라이언트가 로그인하면 서버에서 JWT를 생성하여 반환 
2. 클라이언트는 JWT를 저장(예: 로컬 스토리지, 세션, 쿠키 등)하고 요청마다 포함하여 서버로 전송 
3. 서버는 JWT의 서명을 검증하여 유효한지 확인하고, 요청을 처리함

##### 장점
- 세션 관리 없이 인증 가능
- 요청마다 인증을 위해 DB 조회할 필요 없음
- 확장성이 좋고, 다양한 환경에서 사용 가능

##### 단점
- 길이가 길어 네트워크 트래픽 증가 가능
- 비밀 키 유출 시 보안 문제 발생
- 한 번 발급된 JWT는 무효화하기 어려움 (만료시간이 지나야 함)

### ◉ 사용자 서비스
serverless.yml은 코그니토 리소스가 포함된 다른 파일 2개를 임포트한다.
```yaml
service: chapter4users
frameworkVersion: ">=4.0.0"
custom:
  region: ${env:AWS_DEFAULT_REGION, 'ap-northeast-2'}
  accountid: ${env:AWS_ACCOUNT_ID}
  stage: ${self:provider.stage}
provider:
  name: aws
  runtime: nodejs20.x
  stage: ${opt:stage, 'dev'}
  region: ${env:AWS_DEFAULT_REGION, 'ap-northeast-2'}

resources:
  - ${file(./user-pool.yml)}
  - ${file(./identity-pool.yml)}
```

user-pool.yml은 코그니토 사용자 풀을 설정한다.
```yaml
Resources:
  CognitoUserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: ${self:service}${self:provider.stage}userpool
      UsernameAttributes:
        - email
      AutoVerifiedAttributes:
        - email
      EmailVerificationSubject: 'Your verification code'
      EmailVerificationMessage: 'Your verification code is {####}.'
      Schema:
        - Name: email
          AttributeDataType: String
          Mutable: true
          Required: true
      AdminCreateUserConfig:
        InviteMessageTemplate:
          EmailMessage: 'Your username is {username} and temporary password is {####}.'
          EmailSubject: 'Your temporary password'
        UnusedAccountValidityDays: 2
        AllowAdminCreateUserOnly: true
  CognitoUserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: ${self:service}${self:provider.stage}userpoolclient
      GenerateSecret: false
      UserPoolId:
        Ref: CognitoUserPool
```
- CognitoUserPool: 코그니토 사용자 풀 생성
  - Type: AWS::Cognito::UserPool
  - Properties: 사용자 풀 설정
    - UserPoolName: 사용자 풀 이름
    - UsernameAttributes: 사용자 이름 속성
    - AutoVerifiedAttributes: 자동 확인 속성
    - EmailVerificationSubject: 이메일 확인 제목
    - EmailVerificationMessage: 이메일 확인 메시지
    - Schema: 사용자 속성 스키마
      - Name: 속성 이름
      - AttributeDataType: 속성 데이터 유형
      - Mutable: 변경 가능 여부
      - Required: 필수 여부
    - AdminCreateUserConfig: 관리자 사용자 생성 설정
      - InviteMessageTemplate: 초대 메시지 템플릿
        - EmailMessage: 이메일 메시지
        - EmailSubject: 이메일 제목
    - UnusedAccountValidityDays: 사용되지 않은 계정 유효 기간
    - AllowAdminCreateUserOnly: 관리자만 사용자 생성 허용
- CognitoUserPoolClient: 코그니토 사용자 풀 클라이언트 생성
  - Type: AWS::Cognito::UserPoolClient
  - Properties: 사용자 풀 클라이언트 설정
    - ClientName: 클라이언트 이름
    - GenerateSecret: 비밀 생성 여부
    - UserPoolId: 사용자 풀 ID
      - Ref: CognitoUserPool: 사용자 풀 참조

간단한 진행을 위해 이메일과 비밀번호 로그인만 설정한다.

사용자 풀 클라이언트는 사용자 풀과 외부 애플리케이션 간의 통합 브릿지를 제공하며, 코그니토는 하나의 사용자 풀에 대해 다양한 사용자 풀 클라이언트를 지원한다.

코그니토를 통해 AWS 리소스에 권한이 부여된 접근만 허용하기 위해서는 자격 증명 풀도 필요하다. indentity-pool.yml은 이를 설정한다.
```yaml
Resources:
  CognitoIdentityPool:
    Type: AWS::Cognito::IdentityPool
    Properties:
      IdentityPoolName: ${self:service}${self:provider.stage}identitypool
      AllowUnauthenticatedIdentities: false
      CognitoIdentityProviders:
        - ClientId:
            Ref: CognitoUserPoolClient
          ProviderName:
            Fn::GetAtt: [ "CognitoUserPool", "ProviderName" ]
            
  CognitoIdentityPoolRoles:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    Properties:
      IdentityPoolId:
        Ref: CognitoIdentityPool
      Roles:
        authenticated:
          Fn::GetAtt: [CognitoAuthRole, Arn]
          
  CognitoAuthRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Federated: 'cognito-identity.amazonaws.com'
            Action:
              - 'sts:AssumeRoleWithWebIdentity'
            Condition:
              StringEquals:
                'cognito-identity.amazonaws.com:aud':
                  Ref: CognitoIdentityPool
              'ForAnyValue:StringLike':
                'cognito-identity.amazonaws.com:amr': authenticated
      Policies:
        - PolicyName: 'CognitoAuthorizedPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action:
                  - 'cognito-sync:*'
                  - 'cognito-identity:*'
                  - 'S3:*'
                  - 'transcribe:*'
                  - 'polly:*'
                  - 'lex:*'
                Resource: '*'
              - Effect: 'Allow'
                Action:
                  - 'execute-api:Invoke'
                Resource:
                  Fn::Join:
                    - ''
                    -
                      - 'arn:aws:execute-api:'
                      - Ref: AWS::Region
                      - ':'
                      - Ref: AWS::AccountId
                      - ':*/*'
```

###### CognitoUserPool과 CognitoUserPoolClient가 생성되면, Fn::GetAtt: [ "CognitoUserPool", "ProviderName" ]을 사용해 해당 User Pool의 ProviderName을 가져와 Cognito Identity Pool에 연결한다.
- CognitoIdentityPool: 코그니토 ID 풀 생성
  - Type: AWS::Cognito::IdentityPool
  - Properties: ID 풀 설정
    - IdentityPoolName: ID 풀 이름
    - AllowUnauthenticatedIdentities: 인증되지 않은 ID 허용 여부
    - CognitoIdentityProviders: 코그니토 ID 인증 제공자 설정
      - ClientId: 클라이언트 ID 
      - ProviderName: 제공자 이름
        - Fn::GetAtt: [ "CognitoUserPool", "ProviderName" ]

###### CognitoAuthRole IAM 역할이 생성되면, Fn::GetAtt: [CognitoAuthRole, Arn]을 사용해 해당 역할의 ARN을 가져와 Cognito Identity Pool에 연결한다.
- CognitoIdentityPoolRoles: 코그니토 ID 풀 역할 연결
  - Type: AWS::Cognito::IdentityPoolRoleAttachment
  - Properties: ID 풀 역할 설정
    - IdentityPoolId: ID 풀 ID
    - Roles: 역할
      - authenticated: 인증된 사용자 역할
        - Fn::GetAtt: [CognitoAuthRole, Arn]

###### CognitoIdentityPool을 인증 제공자로 설정한 CognitoAuthRole IAM 역할이 생성되면, 인증된 사용자가 AWS 리소스 및 API Gateway를 사용할 수 있도록 권한을 부여한다.
- CognitoAuthRole: 코그니토 인증 역할 생성
  - Type: AWS::IAM::Role
  - Properties: 역할 설정
    - Path: 역할 경로 설정
    - AssumeRolePolicyDocument: 역할을 맡을 수 있는 주체 및 조건 정의
      - Version: 정책 버전
      - Statement: 정책 내용
        - Effect: Allow' (권한 허용)
        - Principal: 주체
          - Federated: 'cognito-identity.amazonaws.com'
        - Action
          - 'sts:AssumeRoleWithWebIdentity' (웹 인증을 통한 역할 획득 허용) 
        - Condition: 인증된 사용자에 대한 역할 부여 조건
          - StringEquals: 문자열 동일 여부
            - 'cognito-identity.amazonaws.com:aud': Identity 풀 ID
          - 'ForAnyValue:StringLike': 문자열 유사 여부
            - 'cognito-identity.amazonaws.com:amr': authenticated (인증된 사용자만 이 역할 사용 가능)
  - Policies: 정책 설정
    - PolicyName: 정책 이름
    - PolicyDocument: 정책 내용
      - Version: 정책 버전
      - Statement: 정책 내용
        - Effect: 'Allow' (권한 허용)
        - Action: 허용할 작업
          - 'cognito-sync:*' (Cognito 동기화 관련 모든 작업 허용)
          - 'cognito-identity:*' (Cognito ID 관련 모든 작업 허용)
          - 'S3:* (S3 버킷 관련 모든 작업 허용)
          - 'transcribe:*' (AWS Transcribe(음성 → 텍스트 변환) 서비스 사용 허용)
          - 'polly:*' (AWS Polly(텍스트 → 음성 변환) 서비스 사용 허용)
          - 'lex:*' (AWS Lex(챗봇) 서비스 사용 허용)
        - Resource: 작업 대상 리소스
          - '*' (모든 리소스 허용)
        - Effect: 'Allow' (API 호출 허용)
        - Action: 허용할 작업
          - 'execute-api:Invoke' (API Gateway 호출 허용)
        - Resource: API 리소스
          - Fn::Join: API Gateway ARN을 동적으로 생성
            - 'arn:aws:execute-api:'
            - Ref: AWS::Region
            - ':'
            - Ref: AWS::AccountId
            - ':*/*' (모든 API Gateway 엔드포인트 호출 허용)

##### ❗️ Fn::GetAtt란?
AWS CloudFormation의 내장 함수 중 하나로, 특정 리소스의 속성을 가져오는 역할을 한다. 리소스명의 속성명을 지정하여 해당 리소스의 속성을 가져올 수 있다.
> Fn::GetAtt: [리소스명, 속성명]

##### ❗️ ProviderName이란?
CognitoUserPool 리소스 생성 시에 자동으로 생성되는 속성으로, 사용자 풀의 제공자 이름을 나타낸다.

<img src="../../resources/images/chapter_2.서비리스 AI 활용하기/사용자 풀과 자격 증명 풀.jpg" alt="사용자 풀과 자격 증명 풀" style="width: 100%; height: auto;" />

### ◉ 작업 목록 서비스
보안을 적용하려는 모든 진입점에 권한 부여자를 선언하고 사용자 풀 식별자인 CHAPTER4_POOL_ARN을 포함하도록 serverless.yml을 수정한다.
```yaml
custom:
  poolArn: ${env:CHAPTER4_POOL_ARN}

functions:
  create:
    handler: handler.create
    events:
      - http:
          method: POST
          path: todo
          cors: true
          authorizer:
            arn: '${self:custom.poolArn}'
  read:
    handler: handler.read
    events:
      - http:
          method: GET
          path: todo/{id}
          cors: true
          authorizer:
            arn: '${self:custom.poolArn}'
  update:
    handler: handler.update
    events:
      - http:
          method: PUT
          path: todo/{id}
          cors: true
          authorizer:
            arn: '${self:custom.poolArn}'
  delete:
    handler: handler.delete
    events:
      - http:
          method: DELETE
          path: todo/{id}
          cors: true
          authorizer:
            arn: '${self:custom.poolArn}'
  list:
    handler: handler.list
    events:
      - http:
          method: GET
          path: todo
          cors: true
          authorizer:
            arn: '${self:custom.poolArn}'
``` 

- poolArn: 사용자 풀 ARN
- authorizer: API 게이트웨이에 대한 인증자 설정
  - arn: 사용자 풀 ARN

### ◉ 프론트엔드 서비스
프론트엔드를 업데이트하여 로그인, 로그아웃, 토큰 관리를 추가하자. 앞에서 프론트엔드 package.json에 AWS 앰플리파이를 종속성으로 추가했는데, 앰플리파이는 몇 가지 설정 파라미털르 필요로 한다. index.js에서 확인할 수 있다.
```javascript
// index.js
// oauth 인증 관련 설정
const oauth = {
  domain: process.env.CHAPTER4_COGNITO_DOMAIN, // 코그니토 도메인
  scope: ['email'], // 요청할 권한 범위(이메일 정보)
  redirectSignIn: `https://s3-${process.env.TARGET_REGION}.amazonaws.com/${process.env.CHAPTER4_BUCKET}/index.html`, // 로그인 성공 후 리다이렉트할 URL
  redirectSignOut: `https://s3-${process.env.TARGET_REGION}.amazonaws.com/${process.env.CHAPTER4_BUCKET}/index.html`, // 로그아웃 후 리다이렉트할 URL
  responseType: 'token' // 인증 응답 유형
}

// Amplify 인증 설정
Amplify.configure({
  Auth: {
    region: process.env.TARGET_REGION,
    userPoolId: process.env.CHAPTER4_POOL_ID, // 사용자 풀 ID
    userPoolWebClientId: process.env.CHAPTER4_POOL_CLIENT_ID, // 사용자 풀 클라이언트 ID
    identityPoolId: process.env.CHAPTER4_IDPOOL, // identity 풀 ID
    mandatorySignIn: false, // 필수 로그인 여부
    oauth: oauth // oauth 설정 적용
  }
})

$(function () {
  // 사용자 인증
  auth.activate().then((user) => {
    if (user) {
      todo.activate(auth)
    }
  })
})
```

설정은 두 영역으로 구분된다. 먼저 도메인 이름과 리다이렉트 URL을 규정하여 OAuth를 설정한다. 이 OAuth는 변경 사항을 배포하는 동시에 설정되는 코그니토의 설정과 일치해야 한다.
다음으로 풀 식별자와 함께 앰플리아리를 설정하는데, 배포 중에 ID를 가져와서 환경 파일을 조정할 것이다. 로그인 구현은 auth.js 및 auth-view.js에 의해 처리된다.

```javascript
// auth.js
// 로그인/로그아웃 버튼 이벤트 바인딩
function bindLinks () {
  $('#logout').unbind('click')
  $('#logout').on('click', e => {
    // 로그아웃 처리
    Auth.signOut().catch(() => {})
  })

  $('#login').unbind('click')
  $('#login').on('click', e => {
    // 앰플리파이 인증 설정 가져오기
    const config = Auth.configure()
    // oauth 인증 관련 설정 가져오기
    const { domain, redirectSignIn, responseType } = config.oauth
    const clientId = config.userPoolWebClientId
    const url = 'https://' + domain + '/login?redirect_uri=' + redirectSignIn + '&response_type=' + responseType + '&client_id=' + clientId
    // 로그인 페이지로 이동
    window.location.assign(url)
  })
}

// 사용자 정보 가져오기
function user () {
  // 앰플리파이에서 코그니토 유저 풀을 사용하여 사용자 정보 가져오기
  return Auth.currentAuthenticatedUser()
}

// 세션 정보 가져오기
function session () {
  // 앰플리파이에서 코그니토 유저 풀을 사용하여 세션 정보 가져오기
  return Auth.currentSession()
}

// 초기화 및 로그인 상태 확인
function activate () {
  return new Promise((resolve, reject) => {
    Auth.currentAuthenticatedUser()
            .then(user => {
              // 로그인/로그아웃 버튼 렌더링
              view.renderLink(true)
              // 로그인/로그아웃 버튼 이벤트 바인딩
              bindLinks()
              // 사용자 정보 반환
              resolve(user)
            })
            .catch(() => {
              view.renderLink(false)
              bindLinks()
              resolve(null)
            })
  })
}

// auth-view.js
// 로그인/로그아웃 버튼 렌더링
function renderLink (isAuth) {
  $('#navbarNav').html(navBarTpl(isAuth))
}

// templates.js
// 로그인 여부에 따른 로그인/로그아웃 버튼을 포함한 네비게이션 바 템플릿 생성
function navBarTpl (isAuth) {
  let link

  if (isAuth) {
    link = '<a class="nav-link" href="#" id="logout">Logout</a>'
  } else {
    link = '<a class="nav-link" href="#" id="login">Login</a>'
  }

  return `
  <ul class="navbar-nav" id='navbar-list'>
    <li class="nav-item">
      ${link}
    </li>
  </ul>`
}
```

auth.js는 대부분의 작업을 앰플리파이에서 처리한다. activate 함수에서 사용자의 로그인 여부를 확인한 후 뷰를 호출하여 로그인 또는 로그아웃 링크를 렌더링하며, 코그니토 로그인 페이지로 리다이렉션되는 로그인 핸들러를 제공한다.

코그니토에서 얻은 JWT가 API로 전달되는데 필요한 권한 승인 헤더를 포함하도록 to.do.js의 모든 함수를 업데이트하였다.
```javascript
// todo.js
// 새로운 작업을 생성
function create (cb) {
  // 세션을 획득
  auth.session().then(session => {
    $.ajax(API_ROOT, {
      data: JSON.stringify(gather()),
      contentType: 'application/json',
      type: 'POST',
      headers: {
        // 세션 토큰을 헤더에 추가
        Authorization: session.idToken.jwtToken
      },
      success: function (body) {
        if (body.stat === 'ok') {
          list(cb)
        } else {
          $('#error').html(body.err)
          cb && cb()
        }
      }
    })
  }).catch(err => view.renderError(err))
}

// 작업을 업데이트
function update (cb) {
  auth.session().then(session => {
    $.ajax(API_ROOT + $('#todo-id').val(), {
      data: JSON.stringify(gather()),
      contentType: 'application/json',
      type: 'PUT',
      headers: {
        Authorization: session.idToken.jwtToken
      },
      success: function (body) {
        if (body.stat === 'ok') {
          list(cb)
        } else {
          $('#error').html(body.err)
          cb && cb()
        }
      }
    })
  }).catch(err => view.renderError(err))
}

// 작업을 삭제
function del (id) {
  auth.session().then(session => {
    $.ajax(API_ROOT + id, {
      type: 'DELETE',
      headers: {
        Authorization: session.idToken.jwtToken
      },
      success: function (body) {
        if (body.stat === 'ok') {
          list()
        } else {
          $('#error').html(body.err)
        }
      }
    })
  }).catch(err => view.renderError(err))
}

// 작업 목록을 불러옴
function list (cb) {
  auth.session().then(session => {
    $.ajax(API_ROOT, {
      type: 'GET',
      headers: {
        Authorization: session.idToken.jwtToken
      },
      success: function (body) {
        if (body.stat === 'ok') {
          view.renderList(body)
        } else {
          view.renderError(body)
        }
        cb && cb()
      },
      fail: function (jqXHR, textStatus, errorThrown) {
        alert(textStatus)
        alert(errorThrown)
      }
    })
  }).catch(err => view.renderError(err))
}
```

### ◉ 2단계 배포

#### ✦ 코그니토 풀 배포
step-2-cognito-login/user-service로 이동하여 풀을 배포하자
> serverless deploy

추가 설정을 하기 위해 AWS 콘솔에 로그인한 다음 코그니토 메뉴로 이동하자. (️❗️도서에는 도메인 생성하는 AWS 콘솔 구조가 다르니 참고하자)
charpter4usersdevuserpool 풀을 선택하고 도메인 이름을 제공하기 위해 도메인 섹션에서 작업 버튼을 눌러 코그니토 도메인 생성을 한다.

다음으로 OAuth 흐름을 설정해야 한다. 앱 클라이언트 섹션에서 chapter4usersdevuserpoolclient에 들어가 로그인 페이지 탭에서 편집을 눌러 설정을 변경하자.

로그인/로그아웃 페이지에 대한 콜백 URL을 등록하고 자격 증명 공급자로 코그니토 사용자 풀을 선택한다.
그 뒤 OAuth2.0 권한 부여 유형 설정에는 암시적 권한 부여를 선택한다. 그 다음 OpenID Connect 범위에서 OpenID, 이메일, aws.cognito.signin.user.admin를 순서대로 선택하고 저장한다.

#### ❗️OAuth란?
제3자 애플리케이션이 사용자 인증 없이 특정 서비스의 리소스에 안전하게 접근할 수 있도록 해주는 표준 인증 프로토콜이다.

##### 주요 개념
- 리소스 소유자: 서비스 사용자 (ex: Google 계정 소유자)
- 클라이언트: 사용자 정보를 요청하는 애플리케이션 (ex: 어떤 웹사이트)
- 인증 서버: 사용자의 인증을 처리하는 서버 (ex: Google OAuth 서버)
- 리소스 서버: 사용자 정보를 보관하는 서버 (ex: Google API 서버)
- 액세스 토큰: 사용자 데이터를 가져올 때 필요한 인증 키
- 리프레시 토큰: 액세스 토큰이 만료되었을 때 새로운 토큰을 발급받기 위한 키

##### 동작 방식
1. 사용자가 클라이언트에서 로그인 버튼을 클릭, 클라이언트는 인증 서버로 사용자를 리다이렉트함
2. 사용자가 아이디/비밀번호를 입력하고 내 정보에 접근하도록 허용하면 인증 서버가 인증 코드를 발급
3. 클라이언트가 인증 코드를 사용해 액세스 토큰 요청
4. 인증 서버는 인증 코드가 유효한지 확인한 후 클라이언트에게 액세스 토큰과 리프레시 토큰을 발급
5. 클라이언트가 액세스 토큰을 사용하여 리소스 서버에 데이터 요청, 리소스 서버는 엑세스 토큰이 유효하면 사용자 정보를 반환하여 로그인 처리
6. 액세스 토큰이 만료되면 리프레시 토큰을 사용해 새 액세스 토큰 요청
7. 리플레시 토큰이 만료되면 재 로그인 필요

#### ❗️OIDC (OpenID Connect)란?
OAuth 2.0을 확장하여 사용자 인증을 추가한 프로토콜이다.

##### OAuth 2.0과의 차이점
| 기능                 | OAuth 2.0                         | OpenID Connect (OIDC)               |
|----------------------|--------------------------------|------------------------------------|
| 목적             | API 인증 (Authorization)      | 로그인 + API 인증 (Authentication + Authorization) |
| 토큰 유형        | Access Token만 반환           | ID Token + Access Token 반환      |
| 사용자 정보 제공  | 없음 (추가 API 호출 필요)    | ID Token을 통해 사용자 정보 포함 |
| 보안 수준        | 중간                          | 더 강력한 보안 (ID Token 서명 포함) |
| 사용 예제        | Google Drive API, AWS API 인증 | Google 로그인, Facebook 로그인 |
| 프로토콜         | OAuth 2.0                      | OAuth 2.0 + ID Token 추가        |

##### ID 토큰
로그인된 사용자의 정보를 포함하는 JWT 형식의 토큰이다. OIDC에서 사용되며, 클라이언트가 로그인된 사용자 정보를 확인할 때 사용한다.

##### 동작 방식
1. 사용자가 클라이언트에서 로그인 버튼을 클릭, 클라이언트는 인증 서버로 사용자를 리다이렉트함
2. 사용자가 아이디/비밀번호를 입력하고 내 정보에 접근하도록 허용하면 인증 서버가 인증 코드를 발급
3. 클라이언트가 인증 코드를 사용해 액세스 토큰 및 **ID 토큰**를 요청
4. 인증 서버는 인증 코드가 유효한지 확인한 후 클라이언트에게 액세스 토큰과 리플레시 토큰, **ID 토큰**를 발급
5. **클라이언트가 ID 토큰을 디코딩하여 사용자 정보를 확인하고 클라이언트 상의 로그인 처리, 엑세스 토큰은 실제 리소스 서버에 요청할 때 사용**
6. ID/액세스 토큰이 만료되면 리프레시 토큰을 사용해 새 ID/액세스 토큰 요청

##### ❓사용자 정보만 있다면 ID 토큰은 왜 사용할까?
ID 토큰은 사용자 정보를 요청할 때마다 추가 API 호출을 하지 않아도 되기 때문에 효율적이다. 또한, ID 토큰은 서명되어 있어 변조 여부를 확인할 수 있어 보안성이 높다.

##### ❓ID 토큰이 유출되면 개인정보가 노출되지 않을까?
ID 토큰은 로그인된 사용자의 정보를 포함하므로 유출되면 개인정보 노출 위험이 있다. 다만 ID 토큰에는 민감정보 등은 포함되지 않고 실제 서비스도 이용할 수는 없다.

##### ❗️코그니토는 OAuth 2.0과 OIDC를 모두 지원한다.

마지막으로 사용자 풀에 대해 로그인할 계정을 만들어야 한다. 사용자 섹션으로 접속하여 사용자 생성 버튼을 누르고 이메일 주소와 임시 암호 섹션에서 암호 설정을 옵션을 선택하고 암호를 입력 한 후 사용자를 생성한다.

#### ✦ 환경 업데이트
.env 파일에 코그니토 도메인, 사용자 풀 ID, 사용자 풀 클라이언트 ID, ID 풀을 추가한다. 대부분은 정보는 코그니토 AWS 콘솔에서 확인할 수 있다.

#### ✦ TO-DO API 업데이트
step-2-cognito-login/todo-service로 이동하여 API를 업데이트하자
> npm install
> serverless deploy

#### ✦ 프론트엔드 업데이트
> source ../.env
> npm install
> npm run build
> aws s3 sync dist s3://$CHAPTER4_BUCKET

인증 코드를 포함한 애플리케이션의 새로운 버전이 빌드되어 버킷에 배포된다. 브라우저로 다시 애플리케이션에 접속하면 빈 페이지와 페이지 상단에 로그인 링크가 표시되며, 이 링크를 클릭하면 코그니토 로그인 대화 상자가 나타난다. 로그인하면 애플리케이션이 이전과 같이 작동한다.

코그니토 설정에 필요한 약간의 노력에 비하면 그 이점은 크다. 코그니토를 사용하면 다음과 같은 이점을 얻을 수 있다.
- 사용자 등록
- 안전한 JWT 로그인
- AWS IAM 보안 모델에 통합
- 비밀번호 재설정
- 기업 및 소셜 계정(페이스북, 구글, 트위터 등)을 포함하는 연동 자격 증명
- 비밀번호 정책 제어

#### ❗️dotenv-webpack 만 사용할 경우 .env 환경 변수가 치환되지 않는 문제점
dotenv-webpack은 Node.js에서 실행되는 Webpack 프로세스 내부에서만 환경 변수를 설정한다. 하지만, index.js 파일에 있는 환경변수는 그대로 남겨둔다.
Webpack이 번들링할 때 코드 내에서 process.env를 치환하려면 DefinePlugin을 사용해야 한다.

##### ❓DefinePlugin이란?
Webpack의 내장 플러그인 중 하나로, 코드 내에서 사용하는 환경 변수를 번들링할 때 치환해주는 역할을 한다.

##### ❓왜 Webpack은 process.env를 치환하지 않을까?
Webpack은 코드를 읽고 변환하는 역할만 하기 때문에, 코드 내부의 process.env를 치환하지 않는다. DefinePlugin을 사용하면 코드 내부의 process.env를 번들링할 때 치환해준다.
 
## ⭕ 요약
- 클라이언트에서 데이터베이스에 이르는 종단간 서버리스 플랫폼을 코드로 정의하고, 서버리스 프레임워크를 사용하여 배포할 수 있다.
- 다이나모DB 테이블은 serverless.yml 파일의 리소스 섹션의 일부로 생성할 수 있다.
- AWS SDK는 람다 함수가 이벤트에서 전달받은 데이터를 데이터베이스 읽기 및 쓰기 호출로 넘겨주는 데 사용된다.
- AWS 코그니토로 인증 및 권한 부여를 설정할 수 있다. 특정 리소스를 보호하기 위한 정책과 함께 사용자 풀, 자격 증명 풀, 커스텀 도메인을 설정한다.
- AWS 앰플리파이는 코그니토와 함꼐 사용하여 로그인 인터페이스를 생성할 수 있다. 앰플리파이는 코그니토와 통합 가능하며 사용하기 쉬운 AWS의 클라이언트 SDK로, 강력한 보안 기능을 추가할 수 있다.
- API 게이트웨이 CRUD 경로를 생성하여 람다 함수를 트리거할 수 있다. API 게이트웨이 경로는 연결된 람다 함수 또는 핸들러에 연결된 serverless.yml에 정의된 이벤트를 통해 생성된다.
