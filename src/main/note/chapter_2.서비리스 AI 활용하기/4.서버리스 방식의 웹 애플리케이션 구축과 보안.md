1.서버리스 방식의 웹 애플리케이션 구축과 보안
=========================
## ⭕ 아키텍처
<img src="../../resources/images/chapter_2.서비리스 AI 활용하기/챗봇 아키텍처.jpg" alt="챗봇 아키텍처" style="width: 100%; height: auto;" />
- 웹 애플리케이션: S3 버킷이 클라이언트 애플리케이션에 대한 정적인 콘텐츠를 제공하며, API 게이트웨이가 동기 및 비동기 서비스에서 이벤트 핸들러를 트리거하는 API를 제공한다.
웹 애플리케이션 클라이언트는 AWS 앰플리파이 클라이언트 SDK를 사용하여 복잡한 인증을 처리한다.
- 동기 및 비동기 서비스: 이러한 커스텀 서비스는 API 요청을 처리하고 애플리케이션의 주요 비즈니스 로직을 수행하는 AWS 람다 함수로 구현된다.
- 통신 패브릭: 라우트 53은 DNS 구성에 사용된다. 커스텀 도메인 이름을 사용하여 서비스에 접근할 수 있다.
- 유틸리티 서비스: 코그니토는 인증 및 권한 부여에 사용한다.
- AI 서비스: 관리형 AWS AI 서비스인 트랜스크라이브, 폴리, 렉스를 사용한다.
- 데이터 서비스: 다이나모DB는 강력하고 확장 가능한 데이터베이스로 쓰이며, S3는 파일 저장에 쓰인다.

### ◉ 웹 애플리케이션
프론트엔드는 S3에 배포된 HTML, CSS, 자바스크립트로 구성된 단일 페이지 애플리케이션으로 UI를 렌더링한다.
서비스에 대한 경로는 API 게이트웨이를 사용해 제공한다. 작업 목록 애플리케이션은 프론트엔드에 추가 라이브러리, 즉 AWS 앰플리파이를 사용한다.
이번 실습에서는 AWS 앰플리파이를 사용해 코그니토에 클라이언트 인터페이스를 제공하고 S3에 저장한 음성-텍스트 데이터에 접근할 수 있는 권한을 준다.

#### ✦ AWS 앰플리파이(Amplify)
웹 및 모바일 애플리케이션 개발을 위한 풀스택 서비스입니다. 백엔드 구축부터 프론트엔드 배포까지 지원하며, AWS의 다양한 서비스와 쉽게 연동할 수 있습니다.

##### 장점
- 서버리스 기반: 인프라 관리 없이 바로 사용 가능
- 빠른 개발 속도: 인증, 데이터베이스, API 등 쉽게 설정 가능
- 풀스택 지원: 프론트엔드 + 백엔드 통합 관리
- 자동 배포 & CI/CD 지원: 코드 변경 시 자동 빌드 및 배포
- GraphQL 지원: AWS AppSync를 활용한 효율적인 데이터 관리

##### 주요 기능
- 앰플리파이 CLI & Admin UI: 백엔드 설정 (Auth, API, Storage, Functions 등)
- 앰플리파이 Hosting: 정적 웹사이트 배포, CI/CD 지원
- **앰플리파이 라이브러리: AWS 서비스와 프론트엔드 연동 (Auth, API, Storage 등)**
  - 이번 장에서 사용할 기능은 라이브드러리

##### 앰플리파이 라이브러리
프론트엔드 애플리케이션에서 AWS 서비스를 쉽게 연동할 수 있도록 제공되는 클라이언트 라이브러리이다. AWS의 인증, API, 데이터 저장소, 분석 기능 등을 간편하게 구현할 수 있도록 돕는다.

- Authentification: Amazon Cognito 기반 사용자 인증 (로그인, 회원가입, SNS 로그인)
- API (GraphQL & REST): AWS AppSync(GraphQL) 및 API Gateway(REST) 연동 
- Storage (파일 저장): S3 버킷에 파일 업로드 및 다운로드 
- DataStore (오프라인 데이터 동기화): GraphQL API와 연동하여 오프라인에서도 데이터 사용 가능 
- PubSub (실시간 메시징): IoT, WebSocket 등을 활용한 실시간 데이터 처리 
- Predictions (AI/ML 서비스): 이미지 분석, 음성 변환, 번역 기능 제공 
- Geo (위치 기반 서비스): 지도 렌더링 및 위치 데이터 관리 
- Analytics (사용자 행동 분석): AWS Pinpoint 기반 사용자 이벤트 추적

### ◉ 동기 서비스
작업 목록 서비스로 간단한 CRUD 인터페이스에 대한 경로를 노출한다.
- POST /todo/: 새 항목을 작성한다.
- GET /todo/{id}: 특정 항목을 읽는다.
- PUT /todo/{id}: 특정 항목을 업데이트한다.
- DELETE /todo/{id}: 특정 항목을 삭제한다.
- GET /todos: 모든 항목을 나열한다.

### ◉ 비동기 서비스
비동기 서비스는 음성-텍스트 및 텍스트-음성 변환과 관련된 두 가지가 있다.

#### ✦ 노트 서비스
음성 녹음 메모를 텍스트로 변환하는 인터페이스를 제공한다.
- POST /note: 새 비동기 노트 변환 작업을 시작한다.
- GET /note/{id}: 노트에 대한 정보를 폴링한다.

#### ✦ 일정 서비스
일정을 만들어 음성 녹음을 변환하는 인터페이스를 제공한다.
- POST /schedule: 새 비동기 일정 변환 작업을 시작한다.
- GET /schedule/{id}: 일정에 대한 정보를 폴링한다.

### ◉ 통신 패브릭
간결함을 위해 폴 기반 메커니즘을 사용하여 작업 목록을 작성하고, 큐는 사용하지 않는다. 통신 패블릭 기술로는 주로 HTTP와 DNS를 사용한다.

### ◉ 유틸리티 서비스
사용자 로그인 및 인증을 위해 아마존 코그니토를 사용한다.

### ◉ AI 서비스
- 트랜스크라이브: S3에서 입력 내용을 읽어 음성을 텍스트로 변환한다.
- 폴리: 텍스트를 음성으로 변환하고 S3에 출력 오디오 파일을 기록한다.
- 렉스: 대화형 챗봇 생성에 사용하며, 렉스 웹 UI 시스템을 사용하여 프론트엔드 애플리케이션에 직접 연결한다.

#### ✦ 트랜스크라이브(Transcribe)
음성을 텍스트로 변환(STT, Speech-to-Text)하는 AWS의 자동 음성 인식(ASR, Automatic Speech Recognition) 서비스이다.

##### 주요 기능
- 오디오 → 텍스트 변환 (STT): 음성을 자동으로 텍스트로 변환
- 다양한 언어 지원: 영어, 한국어 포함 다국어 지원
- 실시간 전사: 실시간 음성을 텍스트로 변환
- 도메인 최적화 가능: 의료, 콜센터 대화 등 특정 도메인 맞춤 학습, 즉 특화된 모델을 제공
- 맞춤 사전: 특정 용어나 브랜드명 인식 향상, 특정 단어를 등록하여 인식률을 높이는 기능
- 맞춤 언어 모델(Custom Language Models, CLM): 특정 비즈니스 분야에 맞춘 모델 학습, 사용자가 직접 데이터를 업로드하여 AI를 학습시키는 방식
- 화자 분리: 여러 화자를 구분하여 텍스트 변환
- 시간 스탬프 제공: 변환된 텍스트에 시간 정보

#### ✦ 폴리(Polly)
텍스트를 음성으로 변환하는(TTS, Text-to-Speech) AWS 서비스이다.

##### 주요 기능
- 텍스트 → 음성 변환 (TTS, Text-to-Speech): 텍스트를 음성으로 변환
- 다양한 언어 및 음성 지원: 한국어 포함 30개 이상 언어 & 여러 목소리 선택 가능
- Neural TTS: AI 기반 자연스러운 음성 생성
- 음성 감정 조절: 기쁨, 슬픔 등의 감정 표현 가능
- 속도 및 발음 조절: SSML을 사용해 말하기 속도, 억양 조절 가능
- 음성 파일 저장: 음성을 MP3, OGG, PCM 형식으로 저장 가능

#### ✦ 렉스(Lex)
대화형 챗봇과 음성 인터페이스를 쉽게 구축할 수 있도록 지원하는 AWS 서비스이다.

##### 주요 기능
- 음성 & 텍스트 입력 지원: 사용자의 입력을 음성 또는 텍스트로 받아 처리 가능
- 자연어 이해 기반: AI를 활용한 의도 및 개체 인식
- 다중 언어 지원: 영어, 한국어 등 다양한 언어 지원
- Lambda와 연동 가능: AWS Lambda를 활용하여 복잡한 비즈니스 로직 처리 가능
- 자동 음성 합성 지원: AWS Polly와 연동하여 챗봇이 음성으로 응답 가능
- 채널 통합: Slack, Facebook Messenger, Twilio 등과 연결 가능
- 챗봇 분석 기능: AWS CloudWatch를 통한 사용자 데이터 분석 가능

### ◉ 데이터 서비스
데이터 서비스는 S3와 다이나모DB를 사용한다. 다이나모DB는 확장성이 뛰어난 클라우트 네이티브 NoSQL 데이터베이스로 작업 목록을 저장하기 위해 사용한다.

#### ✦ 다이나모DB(DynamoDB)
AWS에서 제공하는 서버리스 NoSQL 데이터베이스 서비스이다. 빠르고 확장성이 뛰어난 키-값(Key-Value) 및 문서(Document) 기반 데이터베이스로, 대량의 데이터를 빠르게 처리할 수 있다.

##### 주요 특징
- 서버리스: 인프라 관리 없이 데이터 저장 및 조회 가능
- NoSQL 기반: 관계형 데이터베이스(RDB)와 달리 스키마 없이 유연한 데이터 저장 가능
- 키-값(Key-Value) 및 문서(Document) 데이터 모델 지원: JSON 형식의 데이터를 저장 가능
- 고성능: SSD 기반으로 빠른 데이터 조회 & 자동 캐싱 지원
- 자동 확장 (Auto Scaling): 수요에 따라 읽기/쓰기 성능 자동 조정
- 완전 관리형: 백업, 복원, 모니터링 기능 제공
- ACID 트랜잭션 지원: 원자성, 일관성, 격리성, 지속성을 보장하는 트랜잭션 기능
- 다양한 AWS 서비스와 연동 가능: Lambda, API Gateway, S3, CloudWatch 등과 쉽게 연결 가능

##### 타 NoSQL 데이터베이스와 비교
| 비교 항목            | DynamoDB                     | MongoDB                   | Cassandra                 | DocumentDB                  |
|---------------------|----------------------------|--------------------------|--------------------------|----------------------------|
| 데이터 모델         | 키-값(Key-Value), 문서(Document) | 문서(Document)           | 키-값(Key-Value), 열(Column) 기반 | 문서(Document)              |
| 트랜잭션 지원       | 기본 지원 (제한적)          | 지원                     | 부분 지원                | 지원                        |
| 조인(Join) 가능 여부 | 미지원                      | 미지원                    | 미지원                    | 미지원                      |
| 스키마             | 없음 (스키마리스)            | 없음 (스키마리스)         | 없음 (스키마리스)         | 없음 (스키마리스)            |
| 확장성             | 자동 확장 (Auto Scaling)     | 자동 확장 (Sharding 필요) | 자동 확장 (노드 추가)     | 자동 확장 (Auto Scaling)     |
| 운영 방식          | AWS 완전 관리형 서버리스     | 자체 호스팅 또는 Atlas (Managed) | 자체 호스팅 필요         | AWS 완전 관리형 (MongoDB 호환) |
| 읽기 성능          | 고속 (DAX 캐싱 지원)         | 빠름                     | 매우 빠름                 | 빠름                        |
| 쓰기 성능          | 초당 수백만 요청 가능        | 빠름                     | 매우 빠름                 | 빠름                        |
| 다중 리전 지원      | 지원 (Global Tables)        | 지원 (Sharding)          | 지원                      | 지원 (Multi-AZ)            |
| 주요 사용 사례      | 서버리스, IoT, 게임, 챗봇, E-commerce | 범용 NoSQL, 웹앱        | 분산 데이터, 대량 데이터  | MongoDB 기반 AWS 애플리케이션 |
| AWS 연동 최적화     | 매우 높음                    | 낮음                     | 낮음                      | 높음                        |
| 비용               | 사용량 기반 과금 (비싼 편)   | 저장 용량 기반 (저렴)    | 대량 데이터 저장 시 저렴  | 사용량 기반 과금 (비싼 편)  |

##### 다이나모 DB를 사용하는 경우
- AWS 생태계 내에서 서버리스, 자동 확장, 고속 읽기/쓰기가 필요한 경우 DynamoDB가 최적의 선택
- 관계형 데이터, SQL 기반 분석, 복잡한 검색 기능이 필요한 경우 다른 DB를 고려하는 것이 좋음

## ⭕ 준비 작업
- AWS 계정
- AWS 커맨드라인 설치 및 설정
- Node.js 설치
- 서버리스 프레임워크 설치

### ◉ 코드 다운로드
소스코드는 https://github.com/hanbit/ai-as-service 저장소의 chapter4 디렉토리에 있다.
> git clone https://github.com/hanbit/ai-as-service.git

## ⭕ 1단계: 기본 애플리케이션
단일 API 게이트웨이 배포, 일부 간단한 람다 함수, 다이나모DB 테이블 및 S3에서 제공되는 일부 프론트엔드 코드를 사용한다.

### ◉ 리소스
serverless.yml 파일은 프론트엔드용 S3 버킷을 정의하고 권한을 설정하며 CORS를 화성화한다. serverless-dotenv-plungin이라는 새로운 플러그인을 사용하여 환경 변수를 설정한다.

##### serverless-dotenv-plungin 플러그인
serverless-dotenv-plugin은 Serverless Framework에서 .env 파일을 로드하여 환경 변수를 자동으로 설정하는 플러그인이다.

### ◉ 작업 목록 서비스
<img src="../../resources/images/chapter_2.서비리스 AI 활용하기/작업 목록 서비스.jpg" alt="작업 목록 서비스" style="width: 100%; height: auto;" />


serverless.yml에서는 핸들러 함수를 위하여 다이나모 DB에 대한 접근을 설정 경로 및 핸들러 함수를 정의한다.
```yaml
service: chapter4-todo
frameworkVersion: ">=4.0.0"
plugins:
  - serverless-offline
  - serverless-domain-manager
  - serverless-dotenv-plugin
custom:
  region: ${env:AWS_DEFAULT_REGION, 'ap-northeast-2'}
  accountid: ${env:AWS_ACCOUNT_ID}
  domain: ${env:CHAPTER4_DOMAIN}
  dotenv:
    path: ../.env
  customDomain:
    domainName: 'chapter4api.${self:custom.domain}'
    stage: ${self:provider.stage}
    basePath: api
    certificateName: '*.${self:custom.domain}'
    certificateArn: ${env:CHAPTER4_DOMAIN_ARN}
    createRoute53Record: true
    endpointType: regional
  serverless-offline:
    port: 3000

provider:
  name: aws
  runtime: nodejs20.x
  stage: ${opt:stage, 'dev'}
  region: ${env:AWS_DEFAULT_REGION, 'ap-northeast-2'}
  environment:
    TODO_TABLE: '${self:service}-${self:provider.stage}'
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:DescribeTable
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
      Resource: "arn:aws:dynamodb:${self:custom.region}:${self:custom.accountid}:*"

functions:
  create:
    handler: handler.create
    events:
      - http:
          method: POST
          path: todo
          cors: true

  read:
    handler: handler.read
    events:
      - http:
          method: GET
          path: todo/{id}
          cors: true
  update:
    handler: handler.update
    events:
      - http:
          method: PUT
          path: todo/{id}
          cors: true
  delete:
    handler: handler.delete
    events:
      - http:
          method: DELETE
          path: todo/{id}
          cors: true
  list:
    handler: handler.list
    events:
      - http:
          method: GET
          path: todo
          cors: true

resources:
  - ${file(./dynamodb.yml)}
```

- iamRoleStatements: 함수가 사용할 IAM 역할을 정의한다.
 - dynamodb:DescribeTable: 테이블에 대한 설명을 가져오는 데 사용
 - dynamodb:Query: 테이블에서 항목을 쿼리하는 데 사용
 - dynamodb:Scan: 테이블에서 모든 항목을 스캔하는 데 사용
 - dynamodb:GetItem: 테이블에서 특정 항목을 가져오는 데 사용
 - dynamodb:PutItem: 테이블에 새 항목을 추가하는 데 사용
 - dynamodb:UpdateItem: 테이블의 기존 항목을 업데이트하는 데 사용
 - dynamodb:DeleteItem: 테이블에서 항목을 삭제하는 데 사용

테이블 이름을 핸들러 함수로 하드 코딩하면 DRY 원칙을 위반하므로 아래 방식을 권장한다.
> TODO_TABLE: '${self:service}-${self:provider.stage}'

##### DRY 원칙
Don't Repeat Yourself의 약자로, 중복을 피하고 코드의 재사용성을 높이기 위한 소프트웨어 개발 원칙이다.

서버리스 정의를 보다 관리하도록, 다이나모DB 테이블 정의를 dynamodb.yml 이라는 별도의 파일을 배치하여 기본 serverless.yml 파일에 포함되도록 선택한다.
```yaml
Resources:
  TodosDynamoDbTable:
    Type: 'AWS::DynamoDB::Table'
    DeletionPolicy: Retain
    Properties:
      AttributeDefinitions:
        -
          AttributeName: id
          AttributeType: S
      KeySchema:
        -
          AttributeName: id
          KeyType: HASH
      ProvisionedThroughput:
        ReadCapacityUnits: 1
        WriteCapacityUnits: 1
      TableName: '${self:service}-${self:provider.stage}'

  GatewayResponseDefault4XX:
    Type: 'AWS::ApiGateway::GatewayResponse'
    Properties:
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
      ResponseType: DEFAULT_4XX
      RestApiId:
        Ref: 'ApiGatewayRestApi'
```

- Type: 'AWS::DynamoDB::Table': 다이나모DB 테이블을 생성하는 리소스 유형
- DeletionPolicy: Retain: 스택 삭제 시 테이블을 유지하도록 설정
- AttributeDefinitions: 테이블의 속성 정의
 - AttributeName: id: 속성 이름
 - AttributeType: S: 속성의 데이터 유형 (문자열)
- KeySchema: 테이블의 기본 키 정의
 - AttributeName: id: 기본 키로 사용할 속성 이름
 - KeyType: HASH: 키 유형 (해시)
- ProvisionedThroughput: 테이블의 읽기/쓰기 처리량 설정
 - ReadCapacityUnits: 1: 초당 1개의 읽기 가능
 - WriteCapacityUnits: 1: 초당 1개의 쓰기 가능
- TableName: '${self:service}-${self:provider.stage}': 테이블 이름을 서비스 이름과 스테이지로 설정
- GatewayResponseDefault4XX: API 게이트웨이 응답을 설정하는 리소스
 - Type: 'AWS::ApiGateway::GatewayResponse': API 게이트웨이 응답을 생성하는 리소스 유형 
 - ResponseParameters: 응답 헤더를 설정
  - gatewayresponse.header.Access-Control-Allow-Origin: "'*'": 모든 도메인에서 API 요청 허용
  - gatewayresponse.header.Access-Control-Allow-Headers: "'*'": 모든 HTTP 헤더 허용
 - ResponseType: DEFAULT_4XX: 기본 4XX 응답
 - RestApiId: Ref: 'ApiGatewayRestApi': API 게이트웨이 리소스 ID 참조, 즉 현재 배포되는 API Gateway와 연결됨

##### 다이나모DB 컬럼 타입
- S: 문자열
- N: 숫자
- B: 바이너리 데이터

##### 다이나모 DB 키 유형
- HASH: 해시 키 (기본 키)
- RANGE: 범위 키 (복합 키)

작업 목록 서비스를 위해 handler.js 파일을 작성한다.
```javascript
'use strict'

const uuid = require('uuid')
const AWS = require('aws-sdk')
// 다이나모DB와 상호작용할 수 있는 DocumentClient 객체를 생성
const dynamoDb = new AWS.DynamoDB.DocumentClient()
const TABLE_NAME = { TableName: process.env.TODO_TABLE }

// 응답을 생성하는 함수
function respond (err, body, cb) {
  let statusCode = 200

  body = body || {}
  if (err) {
    body.stat = 'err'
    body.err = err
    if (err.statusCode) {
      statusCode = err.statusCode
    } else {
      statusCode = 500
    }
  } else {
    body.stat = 'ok'
  }

  const response = {
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Credentials': true,
      statusCode: statusCode
    },
    body: JSON.stringify(body)
  }

  cb(null, response)
}

// action과 note가 빈 문자열이면 null로 변경 (다이나모 DB에 빈 문자열을 저장할 수 없음)
function removeEmpty (data) {
  if (data.action.length === 0) { data.action = null }
  if (data.note.length === 0) { data.note = null }
}

// 다이나모 DB에 데이터를 저장하는 함수
module.exports.create = (event, context, cb) => {
  const data = JSON.parse(event.body)
  // action과 note가 빈 문자열이면 null로 변경
  removeEmpty(data)

  // uuid를 생성하여 id로 사용
  data.id = uuid.v1()
  data.modifiedTime = new Date().getTime()

  const params = { ...TABLE_NAME, Item: data }
  // DynamoDB에 데이터를 저장
  dynamoDb.put(params, (err, data) => {
    respond(err, {data: data}, cb)
  })
}

// 다이나모 DB에서 데이터를 읽어오는 함수
module.exports.read = (event, context, cb) => {
  const params = { ...TABLE_NAME, Key: { id: event.pathParameters.id } }
  // DynamoDB에서 데이터를 읽어옴
  dynamoDb.get(params, (err, data) => {
    respond(err, data, cb)
  })
}

// 다이나모 DB에 데이터를 업데이트하는 함수 (다이나모 DB put은 Upsert 동작)
module.exports.update = (event, context, cb) => {
  const data = JSON.parse(event.body)
  removeEmpty(data)

  data.id = event.pathParameters.id
  data.modifiedTime = new Date().getTime()
  const params = { ...TABLE_NAME, Item: data }

  // DynamoDB에 데이터를 업데이트
  dynamoDb.put(params, (err, data) => {
    console.log(err)
    console.log(data)
    respond(err, data, cb)
  })
}

// 다이나모 DB에서 데이터를 삭제하는 함수
module.exports.delete = (event, context, cb) => {
  const params = { ...TABLE_NAME, Key: { id: event.pathParameters.id } }
  // DynamoDB에서 데이터를 삭제
  dynamoDb.delete(params, (err, data) => {
    respond(err, data, cb)
  })
}

// 다이나모 DB에서 데이터를 읽어오는 함수 (모든 데이터를 읽어옴)
module.exports.list = (event, context, cb) => {
  const params = TABLE_NAME
  // DynamoDB에 데이터를 스캔
  dynamoDb.scan(params, (err, data) => {
    respond(err, data, cb)
  })
}
```

### ◉ 프론트엔드
<img src="../../resources/images/chapter_2.서비리스 AI 활용하기/프론트엔드.jpg" alt="프론트엔드" style="width: 100%; height: auto;" />

- index.html: 기본 HTML 파일
- index.js: 애플리케이션 진입점
- todo.js: 작업 목록의 모델 및 컨트롤러 코드
- todo-view.js: 작업 목록 DOM의 조작
- template.js: 일반적인 렌더링 템플릿

```html
// index.html
<html>
<head>
  <title>Chapter 4-5</title>
</head>
<body>
  <script src='main.js'></script>

	<nav class="navbar navbar-expand-lg navbar-light bg-light">
		<a class="navbar-brand" href="#">Serverless AI Chapter 4-5</a>
		<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
			<span class="navbar-toggler-icon"></span>
		</button>
		<div class="collapse navbar-collapse" id="navbarNav">
		</div>
	</nav>

	<div id="content">
	</div>

	<div id="footer">
		<div id="error"></div>
	</div>

</body>
</html>
```

```javascript
// index.js
'use strict'

import $ from 'jquery'
import 'bootstrap/dist/css/bootstrap.min.css'
import 'webpack-jquery-ui/css'
import {todo} from './todo'

$(function () {
  todo.activate()
})
```

```javascript
// todo.js
'use strict'

import $ from 'jquery'
import {view} from './todo-view'

const todo = {activate}
export {todo}

const API_ROOT = `https://chapter4api.${process.env.CHAPTER4_DOMAIN}/api/todo/`

// 사용자 입력을 수집하여 객체로 반환
function gather () {
  return {
    id: $('#todo-id').val(),
    dueDate: $('#todo-duedate').val(),
    action: $('#todo-action').val(),
    stat: $('#todo-stat').is(':checked') ? 'done' : 'open',
    note: $('#todo-note').val()
  }
}

// 새로운 작업을 생성
function create (cb) {
  $.ajax(API_ROOT, {
    data: JSON.stringify(gather()),
    contentType: 'application/json',
    type: 'POST',
    success: function (body) {
      if (body.stat === 'ok') {
        // 작업 목록을 다시 불러옴
        list(cb)
      } else {
        $('#error').html(body.err)
        cb && cb()
      }
    }
  })
}

// 작업을 업데이트
function update (cb) {
  $.ajax(API_ROOT + $('#todo-id').val(), {
    data: JSON.stringify(gather()),
    contentType: 'application/json',
    type: 'PUT',
    success: function (body) {
      if (body.stat === 'ok') {
        list(cb)
      } else {
        $('#error').html(body.err)
        cb && cb()
      }
    }
  })
}

// 작업을 삭제
function del (id) {
  $.ajax(API_ROOT + id, {
    type: 'DELETE',
    success: function (body) {
      if (body.stat === 'ok') {
        list()
      } else {
        $('#error').html(body.err)
      }
    }
  })
}

// 작업 목록을 불러옴
function list (cb) {
  $.get(API_ROOT, function (body) {
    if (body.stat === 'ok') {
      // 작업 목록을 렌더링
      view.renderList(body)
    } else {
      // 에러 메시지를 렌더링
      view.renderError(body)
    }
    cb && cb()
  })
}

// 리스트 관련 이벤트 핸들러를 바인딩
function bindList () {
  // 편집 이벤트 바인딩
  $('.todo-item-edit').unbind('click')
  $('.todo-item-edit').on('click', (e) => {
    // 편집 영역을 렌더링하고 데이터를 채움
    view.renderEditArea(e.currentTarget.id)
  })

  // 삭제 이벤트 바인딩
  $('.todo-item-delete').unbind('click')
  $('.todo-item-delete').on('click', (e) => {
    // 작업을 삭제
    del(e.currentTarget.id)
  })
}

// 편집 관련 이벤트 핸들러를 바인딩
function bindEdit () {
  // 새로운 작업 생성 이벤트 바인딩
  $('#input-todo').unbind('click')
  $('#input-todo').on('click', e => {
    e.preventDefault()
    // 편집 영역을 렌더링
    view.renderEditArea()
  })

  // 저장 이벤트 바인딩
  $('#todo-save').unbind('click')
  $('#todo-save').on('click', e => {
    e.preventDefault()
    if ($('#todo-id').val().length > 0) {
      // 작업을 업데이트
      update(() => {
        view.renderAddButton()
      })
    } else {
      // 새로운 작업을 생성
      create(() => {
        view.renderAddButton()
      })
    }
  })

  // 취소 이벤트 바인딩
  $('#todo-cancel').unbind('click')
  $('#todo-cancel').on('click', e => {
    e.preventDefault()
    view.renderAddButton()
  })
}

// 초기화 함수
function activate () {
  // 작업 목록 및 리스트, 편집 관련 이벤트를 바인딩
  list(() => {
    bindList()
    bindEdit()
  })

  // content 하위 DOM 변경 시 이벤트 재 바인딩
  $('#content').bind('DOMSubtreeModified', () => {
    bindList()
    bindEdit()
  })
}
```

```javascript
// todo-view.js
'use strict'

import $ from 'jquery'
import 'webpack-jquery-ui/datepicker'
import { todoListTpl, addTpl, editTpl, errTpl } from './templates'

const view = { renderList, renderAddButton, renderEditArea, renderError }
export { view }

// 작업 목록을 렌더링 하는 함수
function renderList (body) {
  $('#content').html(todoListTpl(body.Items))
}

// 작업 추가 버튼을 렌더링 하는 함수
function renderAddButton () {
  $('#edit-area').html(addTpl())
}

// 편집 영역을 렌더링하고 id가 있으면 데이터를 채움
function renderEditArea (id) {
  // 편집 영역을 렌더링
  $('#edit-area').html(editTpl())
  // $('#todo-duedate').datepicker() 없어도 되지 않을까?
  setTimeout(function () {
    $('#todo-duedate').datepicker()
    // id가 있으면 편집 영역을 채움
    if (id) {
      $('#todo-id').val(id)
      $('#todo-duedate').val($('#' + id + ' #due-date').text())
      $('#todo-action').val($('#' + id + ' #action').text())
      // 완료 상태인 경우 체크박스를 체크
      if ($('#' + id + ' #stat').text() === 'done') {
        $('#todo-stat').prop('checked', true)
      }
      $('#todo-note').val($('#' + id + ' #note').text())
    }
  }, 100)
}

// 에러 메시지를 렌더링 하는 함수
function renderError (body) {
  $('#error').html(errTpl(body.err))
}
```

```javascript
// template.js
'use strict'

export { todoListTpl, editTpl, addTpl, errTpl, navBarTpl, navBarScheduleTpl }

// 작업 템플릿 생성
function todoItemTpl (item) {
  return `
    <div id="${item.id}" class="row list-group-item d-flex justify-content-between align-items-center">
      <div class="col-sm-1"></div>
      <div id="due-date" class="col-sm-2">${item.dueDate}</div>
      <div id="action" class="col-sm-3 ">${item.action}</div>
      <div id="note" class="col-sm-3">${item.note === null ? '' : item.note}</div>
      <div id="stat" class="col-sm-1 badge badge-secondary badge-pill">${item.stat}</div>
      <div id="${item.id}" class="col-sm-1 badge badge-danger badge-pill todo-item-delete">Delete</div>
      <div id="${item.id}" class="col-sm-1 badge badge-primary badge-pill todo-item-edit">Edit</div>
    </div>`
}

// 작업 목록을 템플릿 형태로 생성
function todoListTpl (items) {
  let output = ''
  items.forEach(item => {
    output += todoItemTpl(item)
  })


  return `
  <div id="todo-list">
    <div class="row list-group-item d-flex justify-content-between align-items-center">
      <div class="col-sm-1"></div>
      <div class="col-sm-2">Due</div>
      <div class="col-sm-3">Action</div>
      <div class="col-sm-3">Notes</div>
      <div class="col-sm-1">Status</div>
      <div class="col-sm-1"></div>
      <div class="col-sm-1"></div>
    </div>
    ${output}
  </div>
  <div id="edit-area" class="list-group">
    <li class="list-group-item d-flex justify-content-between align-items-center">
      <span id="input-todo" class="badge badge-success badge-pill">new</span>
    </li>
  </div>`
}

// 작업 편집 템플릿 생성
function editTpl () {
  return `
    <div class="row">&nbsp;</div>
    <div class="row">
    <div class="row">
      <div class="col-sm-6">
        <div class="row">
          <div class="col-sm-1"></div><div class="col-sm-1">Due: </div><div class="col-sm-6"><input  class="w-100" type="text" id="todo-duedate"></div>
        </div>
        <div class="row">&nbsp;</div>
        <div class="row">
          <div class="col-sm-1"></div><div class="col-sm-1">Action: </div><div class="col-sm-6"><input class="w-100" type="text" id="todo-action"></div>
        </div>
        <div class="row">&nbsp;</div>
        <div class="row">
          <div class="col-sm-1"></div><div class="col-sm-1">Done: </div><div class="col-sm-6"><input type="checkbox" id="todo-stat"></div>
        </div>
        <div class="row">&nbsp;</div>
        <div class="row">
          <div class="col-sm-1"></div>
          <div class="col-sm-1"><button id="todo-save">save</button></div>
          <div class="col-sm-1"><button id="todo-cancel">cancel</button></div>
          <input type="hidden" id="todo-id">
        </div>
      </div>
      <div class="col-sm-6">
        <div class="row">
          <div class="col-sm-1">Note: </div>
          <div class="col-sm-6">
            <textarea id="todo-note" rows="5" cols="50" maxlength="5000" wrap="hard"></textarea>
          </div>
        </div>
      </div>
    </div>`
}

// 작업 추가 템플릿 생성
function addTpl () {
  return `<li class="list-group-item d-flex justify-content-between align-items-center">
    <span id="input-todo" class="badge badge-success badge-pill">new</span>
  </li>`
}

// 에러 템플릿 생성
function errTpl (err) {
  return `<div class="error">${JSON.stringify(err)}</div>`
}

// 사용하지 않는 함수?
function navBarTpl (isAuth) {
  let link

  if (isAuth) {
    link = '<a class="nav-link" href="#" id="logout">Logout</a>'
  } else {
    link = '<a class="nav-link" href="#" id="login">Login</a>'
  }

  return `
  <ul class="navbar-nav" id='navbar-list'>
    <li class="nav-item">
      ${link}
    </li>
  </ul>`
}

// 사용하지 않는 함수?
function navBarScheduleTpl () {
  return `
    <li class="nav-item">
      <button id='todo-schedule'>schedule</button>
    </li>`
}
```

디스플레이 기능은 todo-view.js 및 template.js가 처리한다.

프론트엔드 디렉토리의 루트에는 세 종류의 제어 파일 package.json, webpack.config.js, serverless.yml이 있다.
이 파일을 사용하여 자바스크립트 종속성을 설치하여 관리하고, 배포할 프론트엔드 버전을 빌드하고, 빌드를 배포할 S3 버킷을 만들 수 있다.

#### ✦ 웹팩
JavaScript 애플리케이션을 위한 모듈 번들러이다. HTML, CSS, JavaScript, 이미지, 폰트 등 다양한 리소스를 하나의 파일 또는 최적화된 여러 개의 파일로 묶어주는 도구이다.

##### 장점
- 파일을 하나로 묶어 관리가 편리함
- 모듈 시스템(ES6 import, CommonJS require) 지원
- 코드를 최적화하여 성능 개선 가능 (압축, 난독화)
- CSS, 이미지, TypeScript 등 다양한 파일을 처리 가능
- 자동으로 변경된 파일을 감지하여 빠른 개발 가능

### ◉ 1단계 배포
환경 변수 설정이 필요하다.
> TARGET_REGION=ap-northeast-2
> CHAPTER4_BUCKET=<사용할 버킷 이름>
> CHAPTER4_DATA_BUCKET=<데이터 버킷 이름>
> CHAPTER4_DOMAIN=<사용할 도메인>
> CHAPTER4_DOMAIN_ARN=<도메인 인증서의 ARN>

#### ✦ 리소스 배포
resources 디렉토리로 이동하여 배포한다.
> npm install
> serverless deploy

#### ✦ 작업 목록 서비스 배포
todo-service 디렉토리로 진입하여 배포한다.
> npm install

##### 도메인 생성
> serverless create_domain

##### 서비스 배포
> serverless deploy

#### ✦ 프론트엔드 배포
frontend 디렉토리로 이동하여 배포한다.
> npm install
> serverless deploy
> source ../.env
> npm run build

##### S3 버킷에 파일 복사
> aws s3 sync dist/ s3://$CHAPTER4_BUCKET
